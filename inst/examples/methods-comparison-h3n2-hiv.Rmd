---
title: "Comparing Topolow with MDS on HIV and H3N2 Datasets"
author: "Omid Arhami"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Comparing Topolow with RACMACS on HIV and H3N2 Datasets}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  warning = TRUE,
 message = TRUE,    # Show messages
  error = TRUE      # Continue on error
)
```

## Introduction

This vignette demonstrates a rigorous comparison between Topolow and RACMACS algorithms using two real antigenic datasets:
1. HIV neutralization data
2. H3N2 influenza HI assay data (Smith et al. 2004)

We conduct 20-fold cross-validation and evaluate performance using multiple metrics including mean absolute error (MAE) and Completeness.

You will need to find the optimal parameters for Topolow first. You can either use parameter fitting scripts to run sufficient number of Monte Carlo simulations on your computers, or use the results of simulations we have provided on Github (the csv files used in this script), or use the parameters provided below:

h3n2_topolow_params <- list(
    N = 4,
    k0 = 14.76214,
    cooling_rate = 0.03641074, 
    c_repulsion = 0.002943064
  )

hiv_topolow_params <- list(
    N = 2,
    k0 = 3.550036,
    cooling_rate = 0.04130713, 
    c_repulsion = 0.0007038619
  )
  
## Setup

First, we'll load required packages and set parameters:

```{r}
library(topolow)
library(Racmacs)
library(data.table)
library(dplyr)
library(parallel)
library(ggplot2)
library(tidyr)
library(gridExtra)
library(cowplot)

# Parameters
opt_setting <- list(
  n_folds = 20,
  max_topolow_iter = 1000,
  topolow_opt_rounds = 1,
  racmacs_opt_rounds = 300,
  num_cores = 59
)

# Setup output directory
output_dir <- "comparison_results"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

# Create output directories if they don't exist
coords_dir <- file.path(output_dir, "coordinates")  
plots_dir <- file.path(output_dir, "plots")
for (dir in c(coords_dir, plots_dir)) {
  if (!dir.exists(dir)) {
    dir.create(dir, recursive = TRUE)
  }
}
```

## Load and Process Data

Load and prepare both datasets:

```{r}
# Combine the two files downloaded from Los Alamos website:
data("hiv_titers")

data("hiv_viruses")

# Add meta data
hiv_viruses <- hiv_viruses %>%
  dplyr::select(c("Virus.name", "Country", "Subtype", "Year"))

hiv_titers <- hiv_titers %>% 
  dplyr::left_join(hiv_viruses, by = join_by(Virus == Virus.name)) %>%
  dplyr::select(c("Antibody", "Virus", "Country", "Subtype", "Year", "IC50")) %>% 
  dplyr::rename("virusYear" = "Year")

hiv_titers <- na.omit(hiv_titers)

hiv_titers <- hiv_titers %>% dplyr::filter(IC50 != "")

hiv_titers <- hiv_titers %>% dplyr::filter(Subtype %in% c("B", "C")) #, "01_AE", "A1", "G", "07_BC", "02_AG", "D", "A1D", "02A1"

hiv_titers$IC50 <- clean_data(hiv_titers$IC50, k=2, take_log=TRUE)
hiv_titers <- na.omit(hiv_titers)

# Sort the dataset based on the "year" column
hiv_titers <- hiv_titers[order(hiv_titers$virusYear), ]

# Save the merged and prepared raw data into a csv:
write.csv(hiv_titers, "data_files/hiv_assay_full.csv")

# Load and process HIV data
hiv_results <- process_antigenic_data(
  file_path = "data_files/hiv_assay_full.csv",
  antigen_col = "Virus",
  serum_col = "Antibody", 
  value_col = "IC50",
  is_titer = FALSE,
  base = 2,
  scale_factor = 1,
  metadata_cols = c("Subtype", "Country")
)

# Extract distance matrix
hiv_distance_matrix <- hiv_results$matrix
hiv_long <- hiv_results$long


# Create filtered dataset
create_filtered_dataset <- function(data, optimal_cutoff, insufficient_thresh) {
  # Find top viruses
  top_viruses <- data %>%
    group_by(virusYear, Virus) %>%
    summarise(n_sera = n_distinct(Antibody), .groups = 'drop') %>%
    group_by(virusYear) %>%
    filter(n_sera > insufficient_thresh) %>%
    slice_max(order_by = n_sera, n = optimal_cutoff)
  
  # Find top sera
  top_sera <- data %>%
    group_by(virusYear, Antibody) %>%
    summarise(n_virus = n_distinct(Virus), .groups = 'drop') %>%
    group_by(virusYear) %>%
    filter(n_virus > insufficient_thresh) %>%
    slice_max(order_by = n_virus, n = optimal_cutoff)
  
  # Create filtered dataset
  filtered_data <- data %>%
    semi_join(top_viruses, by = c("virusYear", "Virus")) %>%
    semi_join(top_sera, by = c("virusYear", "Antibody"))
  
  return(filtered_data)
}

# Create filtered dataset with optimal cutoff=8
insufficient_thresh = 5
optimal_cutoff = 11
filtered_data <- create_filtered_dataset(hiv_long, optimal_cutoff, insufficient_thresh)

# Remove pairs with insufficient measurements (< 3 unique partners)
# Count unique partners for each Antibody and Virus
pairing_counts <- list(
  antibodies = filtered_data %>%
    group_by(Antibody) %>%
    summarise(n_partners = n_distinct(Virus)) %>%
    filter(n_partners >= 3),
  
  viruses = filtered_data %>%
    group_by(Virus) %>%
    summarise(n_partners = n_distinct(Antibody)) %>%
    filter(n_partners >= 3)
)

# Filter data to keep only entries with sufficient partners
filtered_data <- filtered_data %>%
  filter(Antibody %in% pairing_counts$antibodies$Antibody,
         Virus %in% pairing_counts$viruses$Virus)

write.csv(filtered_data, "data_files/hiv_filtered_long_data.csv")

hiv_matrix <- long_to_matrix(filtered_data,
                            chnames = "Virus",
                            rnames = "Antibody", 
                            values_column = "distance",
                            rc = FALSE,
                            sort = TRUE)
```

```{r}
# Count the % of NA values
total_elements <- length(hiv_matrix)
na_count <- sum(is.na(hiv_matrix))
missing_percentage <- (na_count / total_elements) * 100
cat("Percentage of missing values in HIV matrix:", round(missing_percentage, 2), "%\n")
```


```{r}
# Load and process H3N2 data of Smith et al 2004
data(h3n2_data)

write.csv(h3n2_data, "data_files/h3n2_data.csv", row.names = FALSE)

h3n2_results <- process_antigenic_data(
  file_path = "data_files/h3n2_data.csv",
  antigen_col = "virusStrain",
  serum_col = "serumStrain",
  value_col = "titer", 
  is_titer = TRUE,
  metadata_cols = c("virusYear", "serumYear", "cluster", "color")
)
h3n2_long <- h3n2_results$long
h3n2_matrix <- h3n2_results$matrix
```

```{r}
# Count the % of NA values
total_elements <- length(h3n2_matrix)
na_count <- sum(is.na(h3n2_matrix))
missing_percentage <- (na_count / total_elements) * 100
cat("Percentage of missing values in H3N2 matrix:", round(missing_percentage, 2), "%\n")
```


## Load Optimal Parameters

Load and combine parameter chains for both datasets:

```{r}
# HIV parameter chains
hiv_chains <- c(
  "model_parameters/HIV_BC_AMC1_model_parameters.csv",
  "model_parameters/HIV_BC_AMC2_model_parameters.csv",
  "model_parameters/HIV_BC_AMC3_model_parameters.csv",
  "model_parameters/HIV_BC_MC5_model_parameters.csv",
  "model_parameters/HIV_BC_MC6_model_parameters.csv",
  "model_parameters/HIV_BC_MC7_model_parameters.csv",
  "model_parameters/HIV_BC_MC8_model_parameters.csv",
  "model_parameters/HIV_BC_MC9_model_parameters.csv",
  "model_parameters/HIV_BC_MC80_model_parameters.csv"
)

# H3N2 parameter chains  
h3n2_chains <- c(
  "model_parameters/H3N2_2003_data_AMC2_model_parameters.csv",
  "model_parameters/H3N2_2003_data_AMC3_model_parameters.csv",
  "model_parameters/H3N2_2003_data_MC7_model_parameters.csv",
  "model_parameters/H3N2_2003_data_MC8_model_parameters.csv"
)

# Function to get optimal parameters from chains
get_optimal_topolow_params <- function(chain_files) {
  # Read and combine chains
  chains <- do.call(rbind, lapply(chain_files, read.csv))
  
  # Clean and filter
  chains <- chains %>%
    filter(!is.na(NLL) & !is.na(Holdout_MAE) & 
             is.finite(NLL) & is.finite(Holdout_MAE)) %>%
    na.omit()
  
  chains <- chains[chains$log_N >= log(2),]
  
  # Apply clean_data to all columns of the dataframe
  chains <- as.data.frame(lapply(chains, clean_data, k = 10))
  chains <- na.omit(chains)

  # Get best parameters
  best_params <- chains[which.min(chains$Holdout_MAE),]
  
  list(
    N = round(exp(as.numeric(best_params$log_N))),
    k0 = exp(as.numeric(best_params$log_k0)),
    cooling_rate = exp(as.numeric(best_params$log_cooling_rate)), 
    c_repulsion = exp(as.numeric(best_params$log_c_repulsion))
  )
}

# Get optimal parameters for each dataset
hiv_topolow_params <- get_optimal_topolow_params(hiv_chains)
h3n2_topolow_params <- get_optimal_topolow_params(h3n2_chains)

print("HIV optimal parameters:")
print(hiv_topolow_params)
print("\nH3N2 optimal parameters:")
print(h3n2_topolow_params)
```


```{r}
datasets <- list(
  H3N2 = list(
    matrix = h3n2_matrix,
    topolow_params = h3n2_topolow_params,
    racmacs_dim = 4,
    base = 2,        # For titer conversion
    tens = 10,       # For titer conversion
    has_clusters = TRUE
  ),
  HIV = list(
    matrix = hiv_matrix,
    topolow_params = hiv_topolow_params,
    racmacs_dim = 2,
    base = exp(1),   # For titer conversion
    tens = 1,        # For titer conversion
    has_clusters = FALSE
  )
)

```


## Find optimal dimensionality for RACMACS
```{r}
# Find optimal dimensionality for MDS/RACMACS
dimensions_to_test <- 2:10  # Test dimensions from 1D to 10D

# Create output directories if they don't exist
coords_dir <- file.path(output_dir, "coordinates")  
plots_dir <- file.path(output_dir, "plots")
for (dir in c(coords_dir, plots_dir)) {
  if (!dir.exists(dir)) {
    dir.create(dir, recursive = TRUE)
  }
}
# Initialize dimension-specific results storage
dim_results <- data.table(
  Dimension = integer(),
  MAE = numeric(),
  Completeness = numeric(),
  Dataset = character(),
  Algorithm = character(),
  stringsAsFactors = FALSE
)

for(dataset_name in names(datasets)) {
  # Get dataset
  distance_matrix <- datasets[[dataset_name]]$matrix
  
  # Create CV folds
  matrix_list <- create_cv_folds(
    truth_matrix = distance_matrix,
    n_folds = opt_setting$n_folds
  )
  
  # Run each dimension
  for(dim in dimensions_to_test) {
    message(sprintf("Processing %s dataset with dimension %d", dataset_name, dim))
    
    # Storage for this dimension's folds
    fold_mae <- numeric(opt_setting$n_folds)
    fold_Completeness <- numeric(opt_setting$n_folds)
    
    # Run comparison for each fold
    for(i in seq_len(opt_setting$n_folds)) {
      # Get matrices for this fold
      truth_matrix <- matrix_list[[i]][[1]]
      input_matrix <- matrix_list[[i]][[2]]
      
      # Convert to titer format based on dataset
      if(dataset_name == "H3N2") {
        titer_table <- dist_to_titer_table(input_matrix, base=2, tens=10)
      } else {
        titer_table <- dist_to_titer_table(input_matrix, base=exp(1), tens=1)
      }
      
      # Run RACMACS with this dimension
      map <- create_and_optimize_RACMACS_map(
        titer_table = titer_table,
        dim = dim,  # Set the dimension
        optimization_number = opt_setting$racmacs_opt_rounds,
        num_cores = opt_setting$num_cores,
        scenario_name = paste0(dataset_name, "_dim", dim, "_fold", i)
      )
      
      # Save coordinates
      coords_file <- file.path(coords_dir, 
                              paste0(dataset_name, "_RACMACS_dim", dim, "_fold", i, ".csv"))
      save.coords(map, filename = coords_file,
                 optimization_number = 1, antigens = TRUE, sera = TRUE)
      
      # Process RACMACS results
      positions_racmacs <- read.csv(coords_file)
      positions_racmacs$name <- ifelse(
        positions_racmacs$type == "antigen",
        paste0("V/", positions_racmacs$name),
        paste0("S/", positions_racmacs$name)
      )
      
      rownames(positions_racmacs) <- positions_racmacs$name
      positions_racmacs <- positions_racmacs[,3:ncol(positions_racmacs)]
      
      # Calculate distances
      p_dist_mat <- coordinates_to_matrix(as.matrix(positions_racmacs))
      
      # Calculate errors
      racmacs_errors <- error_calculator_comparison(
        p_dist_mat = p_dist_mat,
        truth_matrix = truth_matrix,
        input_matrix = input_matrix
      )
      
      # Store this fold's metrics
      fold_mae[i] <- mean(abs(racmacs_errors$report_df$OutSampleError), na.rm = TRUE)
      fold_Completeness[i] <- racmacs_errors$Completeness
    }
    
    # Calculate averages across folds
    mean_mae <- mean(fold_mae, na.rm = TRUE)
    mean_Completeness <- mean(fold_Completeness, na.rm = TRUE)
    
    # Store dimension results
    dim_results <- rbind(
      dim_results,
      data.table(
        Dimension = dim,
        MAE = mean_mae,
        Completeness = mean_Completeness * 100,  # Convert to percentage
        Dataset = dataset_name,
        Algorithm = "MDS"
      )
    )
  }
}

# Save dimension results
write.csv(dim_results, file.path(output_dir, "racmacs_dimension_results.csv"))

# Create dual axis plots
plot_dimension_results <- function(results, dataset_name) {
  # Filter results for this dataset
  dataset_results <- results[results$Dataset == dataset_name,]
  # Calculate the scaled position for 95% Completeness
  scaled_95_percent <- 95/max(dataset_results$Completeness)*max(dataset_results$MAE)
  
  # Create plot with dual y-axes
  ggplot(dataset_results, aes(x = Dimension)) +
    # MAE line
    geom_line(aes(y = MAE, color = "Validation MAE"), size = 1) +
    geom_point(aes(y = MAE, color = "Validation MAE"), size = 2) +
    # Completeness line (scaled to match MAE range for dual axis)
    geom_line(aes(y = Completeness/max(Completeness)*max(MAE), color = "Completeness"), size = 1) +
    geom_point(aes(y = Completeness/max(Completeness)*max(MAE), color = "Completeness"), size = 2) +
    # Add horizontal line at 95% Completeness
    geom_hline(yintercept = scaled_95_percent, linetype = "dashed", color = "blue", alpha = 0.7) +
    # Add text label for 95% Completeness line
    annotate("text", x = max(dataset_results$Dimension) * 0.7, 
             y = scaled_95_percent * 1.04, 
             label = "Completeness = 95%", 
             color = "blue", hjust = 0, size = 2.4) +
    # Set up axes
    scale_y_continuous(
      name = "Validation MAE",
      sec.axis = sec_axis(~ . * max(dataset_results$Completeness)/max(dataset_results$MAE), 
                          name = "Completeness (%)")) +
    scale_color_manual(values = c("Validation MAE" = "red", "Completeness" = "blue"),
                       name = "Metric") +
    labs(#title = paste(dataset_name, "Dataset"),
         x = "Dimension") +
    theme_minimal() +
    theme(
      panel.grid.minor.y = element_line(size = 0.25,
                                          linetype = 1),
      legend.position = "bottom",
      legend.text = element_text(size = 7),
      legend.title = element_text(size = 7),
      plot.title = element_text(hjust = 0.5, size = 9),
      axis.title = element_text(size = 8),
      axis.text = element_text(size = 7)
    )
}

# Generate individual plots
h3n2_plot <- plot_dimension_results(dim_results, "H3N2")
hiv_plot <- plot_dimension_results(dim_results, "HIV")

# Combine plots side by side
combined_plot <- plot_grid(
  h3n2_plot, hiv_plot,
  labels = c("A. H3N2 data", "B. HIV data"),
  label_size = 7,
  nrow = 1,
  align = 'h',
  axis = 'tb'
)

# Save the combined plot
save_plot(
  file.path(plots_dir, "racmacs_dimension_analysis.pdf"),
  combined_plot,
  ncol = 2,
  nrow = 1,
  base_width = 3.26772*0.9, 
  base_height = 3
)
```

## Create antigenic maps
### Setup
```{r}
# Create visualization configurations
dim_config <- new_dim_reduction_config(
  method = "pca",
  n_components = 2,
  scale = FALSE
)

sc = 1
aesthetic_config <- new_aesthetic_config(
  point_shapes = c(antigen = 16, antiserum = 4),
  point_size = 1.5,
  point_alpha = 0.65,
  gradient_colors = list(low = "blue", high = "red"),
  title_size = 7*sc,
  subtitle_size = 7*sc,
  axis_title_size = 7*sc,
  axis_text_size = 6*sc,
  show_legend = FALSE,
  legend_position = "none",
  show_title = FALSE
)

layout_config <- new_layout_config(
  width = 3.26772*0.47,
  height = 3,
  dpi = 300,
  x_limits = c(-8, 8),
  y_limits = c(-18, 18),
  reverse_x = 1, 
  reverse_y = -1,
  plot_margin = margin(0.05, 0.05, 0.05, 0.05, "cm"),
  save_format = "pdf"
)
```


### Finding coordinates
```{r eval=FALSE}
### Part 1: Find and save coordinates ###
message("\nFinding coordinates for all datasets...")

for (dataset_name in names(datasets)) {
  dataset <- datasets[[dataset_name]]
  distance_matrix <- dataset$matrix
  topolow_params <- dataset$topolow_params
  racmacs_dim <- dataset$racmacs_dim
  
  message(sprintf("\nProcessing %s dataset...", dataset_name))
  
  ######################## Run Topolow
  topo_result <- tryCatch({
    create_topolow_map(
      distance_matrix = distance_matrix,
      ndim = topolow_params$N,
      mapping_max_iter = opt_setting$max_topolow_iter,
      relative_epsilon = 1e-10,
      convergence_counter = 5,
      k0 = topolow_params$k0,
      cooling_rate = topolow_params$cooling_rate,
      c_repulsion = topolow_params$c_repulsion,
      write_positions_to_csv = FALSE,
      verbose = TRUE
    )
  }, error = function(e) {
    warning(sprintf("! Error in Topolow optimization for %s: %s", 
                   dataset_name, e$message))
    return(NULL)
  })
  
  if (!is.null(topo_result)) {
    coords_file <- file.path(coords_dir, 
                           sprintf("topolow_%s_coords.csv", dataset_name))
    positions_df <- as.data.frame(topo_result$positions)
    write.csv(positions_df, coords_file, row.names = TRUE)
  }
  
  
  #################### Run RACMACS
  titer_table <- dist_to_titer_table(distance_matrix, 
                                    base = dataset$base,
                                    tens = dataset$tens)
  
  map <- create_and_optimize_RACMACS_map(
    titer_table = titer_table,
    dim = racmacs_dim,
    optimization_number = opt_setting$racmacs_opt_rounds,
    num_cores = opt_setting$num_cores,
    scenario_name = dataset_name
  )
  
  coords_file <- file.path(coords_dir, 
                         sprintf("racmacs_%s_coords.csv", dataset_name))
  save.coords(map, filename = coords_file,
             optimization_number = 1, antigens = TRUE, sera = TRUE)
}
```


### H3N2
```{r}
### Create plots from saved coordinates ###

# Get H3N2 metadata once
h3n2_metadata <- NULL
if (any(sapply(datasets, function(x) x$has_clusters))) {
  h3n2_metadata <- h3n2_long %>%
    select(virusStrain, cluster, color) %>%
    distinct()
}

#Code below combines H3N2 maps in a 2-panel figure for the paper:

# First verify files exist and check their content
topo_file <- file.path(coords_dir, "topolow_H3N2_coords.csv")
rac_file <- file.path(coords_dir, "racmacs_H3N2_coords.csv")

if (!file.exists(topo_file)) {
  stop("TopoLow coordinates file not found at: ", topo_file)
}
if (!file.exists(rac_file)) {
  stop("RACMACS coordinates file not found at: ", rac_file)
}

# Read and process TopoLow coordinates
positions_topolow <- read.csv(topo_file)
if (nrow(positions_topolow) == 0) {
  stop("TopoLow coordinates file is empty")
}

# Process TopoLow coordinates
positions_topolow$name <- positions_topolow$X  # Restore rownames
positions_topolow$X <- NULL
positions_topolow$antigen <- startsWith(positions_topolow$name, "V/")
positions_topolow$antiserum <- startsWith(positions_topolow$name, "S/")
positions_topolow$year <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", positions_topolow$name))
positions_topolow$name <- sub("^[VS]/", "", positions_topolow$name)

# Add cluster information
if (!exists("h3n2_metadata")) {
  stop("h3n2_metadata not found. Please ensure it's loaded.")
}
positions_topolow <- merge(positions_topolow, h3n2_metadata, 
                         by.x = "name", by.y = "virusStrain", all.x = TRUE)
positions_topolow <- na.omit(positions_topolow)

# Read and process RACMACS coordinates
positions_racmacs <- read.csv(rac_file)
if (nrow(positions_racmacs) == 0) {
  stop("RACMACS coordinates file is empty")
}

# Process RACMACS coordinates
positions_racmacs$name <- ifelse(
  positions_racmacs$type == "antigen",
  paste0("V/", positions_racmacs$name),
  paste0("S/", positions_racmacs$name)
)
positions_racmacs$antigen <- startsWith(positions_racmacs$name, "V/")
positions_racmacs$antiserum <- startsWith(positions_racmacs$name, "S/")
positions_racmacs$year <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", positions_racmacs$name))
positions_racmacs$name <- sub("^[VS]/", "", positions_racmacs$name)
positions_racmacs$V1 <- positions_racmacs$X
positions_racmacs$V2 <- positions_racmacs$X.1

# Add cluster information
positions_racmacs <- merge(positions_racmacs, h3n2_metadata,
                         by.x = "name", by.y = "virusStrain", all.x = TRUE)
positions_racmacs <- na.omit(positions_racmacs)

# Print dimensions to verify data
print(dim(positions_topolow))
print(dim(positions_racmacs))

# Create the individual plots
topolow_plot <- plot_cluster_mapping(
  positions_topolow,
  ndim = datasets$H3N2$topolow_params$N,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config
) + ggtitle("TopoLow")

racmacs_plot <- plot_cluster_mapping(
  positions_racmacs,
  ndim = datasets$H3N2$racmacs_dim,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config
) + ggtitle("RACMACS")

# Combine plots
combined_plot <- plot_grid(
  topolow_plot, racmacs_plot,
  labels = c("A", "B"),
  label_size = 8,
  nrow = 1,
  align = 'h',
  axis = 'tb'
)

# Save combined plot
save_plot(
  file.path(plots_dir, "combined_H3N2_clusters.pdf"),
  combined_plot,
  ncol = 2,
  nrow = 1,
  base_width = 3.26772*0.5,
  base_height = layout_config$height
)
```

### HIV
```{r}
### Create plots from saved coordinates ###

# Get HIV metadata once
hiv_metadata <- NULL
hiv_metadata <- hiv_long %>%
  select(Virus, Subtype) %>%
  distinct()


# First verify files exist and check their content
topo_file <- file.path(coords_dir, "topolow_HIV_coords.csv")
rac_file <- file.path(coords_dir, "racmacs_HIV_coords.csv")

if (!file.exists(topo_file)) {
  stop("TopoLow coordinates file not found at: ", topo_file)
}
if (!file.exists(rac_file)) {
  stop("RACMACS coordinates file not found at: ", rac_file)
}

# Read and process TopoLow coordinates
positions_topolow <- read.csv(topo_file)
if (nrow(positions_topolow) == 0) {
  stop("TopoLow coordinates file is empty")
}

# Process TopoLow coordinates
positions_topolow$name <- positions_topolow$X  # Restore rownames
positions_topolow$X <- NULL
positions_topolow$antigen <- startsWith(positions_topolow$name, "V/")
positions_topolow$antiserum <- startsWith(positions_topolow$name, "S/")
positions_topolow$year <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", positions_topolow$name))
positions_topolow$name <- sub("^[VS]/", "", positions_topolow$name)

# Add cluster information
if (!exists("hiv_metadata")) {
  stop("hiv_metadata not found. Please ensure it's loaded.")
}
positions_topolow <- merge(positions_topolow, hiv_metadata, 
                         by.x = "name", by.y = "Virus", all.x = TRUE)
positions_topolow <- na.omit(positions_topolow)

# Read and process RACMACS coordinates
positions_racmacs <- read.csv(rac_file)
if (nrow(positions_racmacs) == 0) {
  stop("RACMACS coordinates file is empty")
}

# Process RACMACS coordinates
positions_racmacs$name <- ifelse(
  positions_racmacs$type == "antigen",
  paste0("V/", positions_racmacs$name),
  paste0("S/", positions_racmacs$name)
)
positions_racmacs$antigen <- startsWith(positions_racmacs$name, "V/")
positions_racmacs$antiserum <- startsWith(positions_racmacs$name, "S/")
positions_racmacs$year <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", positions_racmacs$name))
positions_racmacs$name <- sub("^[VS]/", "", positions_racmacs$name)
positions_racmacs$V1 <- positions_racmacs$X
positions_racmacs$V2 <- positions_racmacs$X.1

# Add cluster information
positions_racmacs <- merge(positions_racmacs, hiv_metadata,
                         by.x = "name", by.y = "Virus", all.x = TRUE)
positions_racmacs <- na.omit(positions_racmacs)

# Print dimensions to verify data
print(dim(positions_topolow))
print(dim(positions_racmacs))

# Create the individual plots
topolow_plot <- plot_cluster_mapping(
  positions_topolow,
  ndim = datasets$HIV$topolow_params$N,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config
) + ggtitle("TopoLow")

racmacs_plot <- plot_cluster_mapping(
  positions_racmacs,
  ndim = datasets$HIV$racmacs_dim,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config
) + ggtitle("RACMACS")

# Combine plots
combined_plot <- plot_grid(
  topolow_plot, racmacs_plot,
  labels = c("A", "B"),
  label_size = 8,
  nrow = 1,
  align = 'h',
  axis = 'tb'
)

# Save combined plot
save_plot(
  file.path(plots_dir, "combined_HIV_clusters.pdf"),
  combined_plot,
  ncol = 2,
  nrow = 1,
  base_width = 3.26772*0.5,
  base_height = layout_config$height
)
```

## Create data collection tables

```{r}
# Initialize results storage
errors_df <- data.table(
  InSampleError = numeric(),
  OutSampleError = numeric(),
  InSamplePercentageError = numeric(),
  OutSamplePercentageError = numeric(),
  Dimension = numeric(),
  Algorithm = character(),
  Scenario = character(),
  Dataset = character(), 
  Fold = numeric(),
  stringsAsFactors = FALSE
)

Completeness_df <- data.table(
  Mapped = numeric(),
  Total = numeric(),
  Validation_Completeness = numeric(),
  Algorithm = character(),
  Dataset = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

```


## Run Error Comparison

Process each dataset through cross-validation:

```{r eval=FALSE}
# Process each dataset
for(dataset_name in names(datasets)) {
  # Get dataset and parameters
  distance_matrix <- datasets[[dataset_name]]$matrix
  topolow_params <- datasets[[dataset_name]]$topolow_params
  racmacs_dim <- datasets[[dataset_name]]$racmacs_dim
  # Create CV folds
  matrix_list <- create_cv_folds(
    truth_matrix = distance_matrix,
    n_folds = opt_setting$n_folds
  )
  
  # Run comparison for each fold
  for(i in seq_len(opt_setting$n_folds)) {
    # Get matrices for this fold
    truth_matrix <- matrix_list[[i]][[1]]
    input_matrix <- matrix_list[[i]][[2]]
    
    ################# Run Topolow
    
    res_train <- create_topolow_map(
      distance_matrix = input_matrix,
      ndim = topolow_params$N,
      mapping_max_iter = opt_setting$max_topolow_iter,
      k0 = topolow_params$k0,
      cooling_rate = topolow_params$cooling_rate,
      c_repulsion = topolow_params$c_repulsion,
      relative_epsilon = 1e-10,
      convergence_counter = 5,
      initial_positions = NULL,
      write_positions_to_csv = FALSE,
      verbose = TRUE
    )

    p_dist_mat <- res_train$est_distances

    # Calculate Topolow errors
    topo_errors <- error_calculator_comparison(
      p_dist_mat = p_dist_mat,
      truth_matrix = truth_matrix,
      input_matrix = input_matrix
    )

    # Store Topolow results
    topo_df <- topo_errors$report_df
    topo_df$Dimension = topolow_params$N
    topo_df$Algorithm = "Topolow"
    topo_df$Scenario = "Topolow"
    topo_df$Dataset <- dataset_name
    topo_df$Fold <- i

    errors_df <- rbind(errors_df, topo_df)

    Completeness_df <- rbind(
      Completeness_df,
      data.table(
        Mapped = nrow(p_dist_mat),
        Total = nrow(truth_matrix),
        Validation_Completeness = topo_errors$Completeness,
        Algorithm = "Topolow",
        Dataset = dataset_name,
        Fold = i
      )
    )

    
    ################# Run RACMACS
    
    # Convert to titer format
    if(dataset_name == "H3N2") {
      titer_table <- dist_to_titer_table(input_matrix, base=2, tens=10)
    } else {
      titer_table <- dist_to_titer_table(input_matrix, base=exp(1), tens=1)
    }
    
    map <- create_and_optimize_RACMACS_map(
      titer_table = titer_table,
      dim = racmacs_dim,
      optimization_number = opt_setting$racmacs_opt_rounds,
      num_cores = opt_setting$num_cores,
      scenario_name = paste0(dataset_name, "_fold", i)
    )
    
    # Save coordinates
    coords_file <- file.path(output_dir, 
                            paste0(dataset_name, "_RACMACS_coords_", i, ".csv"))
    save.coords(map, filename = coords_file,
               optimization_number = 1, antigens = TRUE, sera = TRUE)
    
    # Process RACMACS results
    positions_racmacs <- read.csv(coords_file)
    positions_racmacs$name <- ifelse(
      positions_racmacs$type == "antigen",
      paste0("V/", positions_racmacs$name),
      paste0("S/", positions_racmacs$name)
    )
    
    rownames(positions_racmacs) <- positions_racmacs$name
    positions_racmacs <- positions_racmacs[,3:ncol(positions_racmacs)]
    
    # Calculate RACMACS distances
    p_dist_mat <- coordinates_to_matrix(as.matrix(positions_racmacs))
    
    racmacs_errors <- error_calculator_comparison(
      p_dist_mat = p_dist_mat,
      truth_matrix = truth_matrix,
      input_matrix = input_matrix
    )
    
    # Store RACMACS results
    racmacs_df <- racmacs_errors$report_df
    racmacs_df$Dimension = 2
    racmacs_df$Algorithm = "MDS"
    racmacs_df$Scenario = "MDS"
    racmacs_df$Dataset <- dataset_name
    racmacs_df$Fold <- i
    
    errors_df <- rbind(errors_df, racmacs_df)
    
    Completeness_df <- rbind(
      Completeness_df,
      data.table(
        Mapped = nrow(p_dist_mat),
        Total = nrow(truth_matrix),
        Validation_Completeness = racmacs_errors$Completeness,
        Algorithm = "MDS",
        Dataset = dataset_name,
        Fold = i
      )
    )
    
  }
}

write.csv(errors_df, file.path(output_dir, "errors_df_loop.csv") )
write.csv(Completeness_df, file.path(output_dir, "Completeness_df_loop.csv") )
```


## Statistical Analysis

```{r}
# Read the CSV files back into dataframes
errors_df <- read.csv(file.path(output_dir, "errors_df_loop.csv"))
Completeness_df <- read.csv(file.path(output_dir, "Completeness_df_loop.csv"))
```


Perform paired t-tests to compare algorithm performance:

```{r}
# Calculate fold-level statistics
fold_stats <- aggregate(
  OutSampleError ~ Dataset + Algorithm + Fold,
  data = errors_df,
  FUN = function(x) mean(abs(x), na.rm = TRUE)
)

# Perform paired t-tests for each dataset
stat_tests <- fold_stats %>%
  group_by(Dataset) %>%
  summarize(
    t_stat = t.test(OutSampleError[Algorithm == "MDS"],
                    OutSampleError[Algorithm == "Topolow"],
                    paired = TRUE)$statistic,
    p_value = t.test(OutSampleError[Algorithm == "MDS"],
                     OutSampleError[Algorithm == "Topolow"],
                     paired = TRUE)$p.value,
    .groups = 'drop'
  ) %>%
  mutate(
    Sig.Level = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**",
      p_value < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  )

print("Statistical Test Results:")
knitr::kable(stat_tests)
```

## Results Visualization

```{r}
# font sizes
base_size <- 7          # Base font size
axis_title_size <- 7    # Size for axis titles
axis_text_size <- 7     # Size for axis text
plot_title_size <- 7    # Size for plot title
legend_title_size <- 7   # Size for legend title
legend_text_size <- 6    # Size for legend text
stat_text_size <- 2.2      # Size for MAE/SD statistics

# Calculate summary statistics
error_summary <- errors_df %>%
  # Remove possible errors in the data using clean_data function with k=10 to remove points 10 SD away.
  group_by(Dataset, Algorithm) %>%
  mutate(
    OutSampleError = clean_data(OutSampleError, k=10)
  ) %>%
  # Calculate summary statistics
  summarise(
    MAE = round(mean(abs(OutSampleError), na.rm=TRUE), 3),
    SD = round(sd(abs(OutSampleError), na.rm=TRUE), 3),
    .groups='drop'
  ) %>%
  mutate(
    label = sprintf("%.3f\n%.3f", MAE, SD)
  )

# Calculate the y-axis range needed
y_range <- range(clean_data(errors_df$OutSampleError, k=3.5), na.rm = TRUE)
y_padding <- abs(diff(y_range)) * 0.22  # 20% padding


p1 <- ggplot() +
  # Add box plots with outliers removed
  geom_boxplot(
    data = errors_df,
    aes(x = Dataset, y = OutSampleError, 
        fill = Algorithm),
    position = position_dodge(width = 0.8),
    outlier.shape = NA,  # Remove outliers
    alpha = 0.8
  ) +
  # Add text labels for MAE and SD
  geom_text(
    data = error_summary,
    aes(x = Dataset, y = y_range[1] - y_padding/2, 
        label = label, group = Algorithm),
    position = position_dodge(width = 0.8),
    vjust = 1,
    size = stat_text_size,
    color = "black"
  ) +
  # Customize appearance
  scale_fill_manual(values = c("Topolow" = "#4dbedf", "MDS" = "#e59572")) +
  scale_y_continuous(
    limits = c(y_range[1] - y_padding, y_range[2] + y_padding/4),
    expand = c(0, 0)
  ) +
  theme_minimal(base_size = base_size) +  # Set base size for theme
  theme(
    # Axis text styling
    axis.title = element_text(size = axis_title_size),
    axis.text = element_text(size = axis_text_size),
    axis.text.x = element_text(hjust = 1),
    
    # Grid styling
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5),
    
    # Plot title styling (if needed)
    plot.title = element_text(size = plot_title_size, hjust = 0.5),
    
    # Legend styling
    legend.position = c(0.5, 0.95),  # Position at top center inside panel
    legend.direction = "horizontal",
    legend.background = element_rect(fill = "white", color = NA),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.margin = margin(1, 1, 1, 1),
    legend.key.size = unit(0.8, "lines"),
    legend.title = element_text(size = legend_title_size),
    legend.text = element_text(size = legend_text_size)
  ) +
  labs(
    x = NULL,
    y = "Error (validation data)",
    fill = "Algorithm"
  )

print(p1)
ggsave(file.path(plots_dir,"comparison_real_data.pdf"),
       p1, width = 83, height = 73, units = "mm")

# Print summary table
knitr::kable(
  error_summary %>% 
    select(Dataset, Algorithm, MAE, SD),
  caption = "Error Summary Statistics"
)
```

```{r}
# Calculate fold-level statistics
fold_stats <- aggregate(
  OutSampleError ~ Dataset + Algorithm + Fold,
  data = errors_df,
  FUN = function(x) mean(abs(x), na.rm = TRUE)
)

# Calculate summary statistics
summary_stats <- fold_stats %>%
  group_by(Dataset, Algorithm) %>%
  summarize(
    Mean = mean(OutSampleError),
    SD = sd(OutSampleError),
    .groups = 'drop'
  )

# Calculate dataset statistics
data_stats <- list(
  HIV = summary(as.numeric(hiv_matrix), na.rm=TRUE),
  H3N2 = summary(as.numeric(h3n2_matrix), na.rm=TRUE)
)

# Add mean distance to summary_stats
summary_stats$MeanDist <- sapply(summary_stats$Dataset, 
                                function(d) mean(as.numeric(datasets[[d]]$matrix), na.rm=TRUE))
summary_stats$RelativeMAE <- summary_stats$Mean / summary_stats$MeanDist * 100

```

Create comparison plots:

```{r}
# Calculate fold-level statistics
fold_stats <- aggregate(
  OutSampleError ~ Dataset + Algorithm + Fold,
  data = errors_df,
  FUN = function(x) mean(abs(x), na.rm = TRUE)
)

# Calculate summary statistics
summary_stats <- fold_stats %>%
  group_by(Dataset, Algorithm) %>%
  summarize(
    Mean = mean(OutSampleError),
    SD = sd(OutSampleError),
    .groups = 'drop'
  )

# Calculate quantile-based statistics for each dataset
data_ranges <- list(
  HIV = quantile(as.numeric(hiv_matrix), 
                 probs = c(0.05, 0.25, 0.5, 0.75, 0.95), 
                 na.rm = TRUE),
  H3N2 = quantile(as.numeric(h3n2_matrix), 
                  probs = c(0.05, 0.25, 0.5, 0.75, 0.95), 
                  na.rm = TRUE)
)

# Create data frame for range lines
range_data <- data.frame(
  Dataset = names(data_ranges),
  ymin = sapply(data_ranges, function(x) x["5%"]),
  ymax = sapply(data_ranges, function(x) x["95%"])
)

# Create the plot
p1 <- ggplot() +
  # Add MAE bars
  geom_bar(data = summary_stats,
           aes(x = Dataset, y = Mean, fill = Algorithm),
           stat = "identity", position = position_dodge()) +
  geom_errorbar(data = summary_stats,
                aes(x = Dataset, y = Mean, 
                    ymin = Mean - SD, ymax = Mean + SD,
                    group = Algorithm),
                position = position_dodge(width = 0.9),
                width = 0.25) +
  scale_fill_manual(values = c("Topolow" = "#3366CC", "MDS" = "#DC3912")) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    legend.position = "top"
  ) +
  labs(
    title = "Out-of-Sample Mean Absolute Error",
    subtitle = paste(
      "Data Ranges (5th-95th percentiles):",
      sprintf("\nHIV: (%.2f - %.2f)", range_data$ymin[[1]], range_data$ymax[[1]]),
      sprintf("\nH3N2: (%.2f - %.2f)", range_data$ymin[[2]], range_data$ymax[[2]])
    ),
    y = "MAE (±SD)"
  )

print(p1)

# Print context statistics
for(dataset in names(data_ranges)) {
  cat("\n", dataset, "statistics:\n")
  print(data_ranges[[dataset]])
  cat("MAE values:\n")
  print(summary_stats[summary_stats$Dataset == dataset,])
}
```



## Summary Tables

Create detailed performance summary tables:

```{r}
# Error summary table
error_summary <- summary_stats %>%
  mutate(
    Performance = sprintf("%.3f ± %.3f", Mean, SD)
  ) %>%
  select(Dataset, Algorithm, Performance) %>%
  tidyr::pivot_wider(names_from = Algorithm,
                     values_from = Performance)

print("Mean Absolute Error Summary:")
knitr::kable(error_summary)


# Completeness summary
Completeness_summary <- Completeness_df %>%
  group_by(Dataset, Algorithm) %>%
  summarize(
    Mean_Completeness = mean(Validation_Completeness),
    SD_Completeness = sd(Validation_Completeness),
    .groups = 'drop'
  ) %>%
  mutate(
    Completeness = sprintf("%.1f%% ± %.1f%%", 
                      Mean_Completeness * 100, 
                      SD_Completeness * 100)
  ) %>%
  select(Dataset, Algorithm, Completeness) %>%
  tidyr::pivot_wider(names_from = Algorithm,
                     values_from = Completeness)

print("\nCompleteness Summary:")
knitr::kable(Completeness_summary)
```

## Distribution of Errors

Examine the distribution of errors for both algorithms:

```{r}
# Calculate error distributions
error_dist <- errors_df %>%
  group_by(Dataset, Algorithm) %>%
  summarize(
    Mean = mean(OutSampleError, na.rm = TRUE),
    SD = sd(OutSampleError, na.rm = TRUE),
    Median = median(OutSampleError, na.rm = TRUE),
    Q1 = quantile(OutSampleError, 0.25, na.rm = TRUE),
    Q3 = quantile(OutSampleError, 0.75, na.rm = TRUE),
    .groups = 'drop'
  )

print("Error Distribution Summary:")
knitr::kable(error_dist)
```

## Session Info

```{r}
sessionInfo()
```
```
