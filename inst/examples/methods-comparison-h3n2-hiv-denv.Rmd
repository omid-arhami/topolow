---
title: "Comparing Topolow with MDS on HIV and H3N2 Datasets"
author: "Omid Arhami"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Comparing Topolow with RACMACS on HIV and H3N2 Datasets}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  warning = TRUE,
 message = TRUE,    # Show messages
  error = TRUE      # Continue on error
)
```

## Introduction

This vignette demonstrates a rigorous comparison between Topolow and RACMACS algorithms using two real antigenic datasets:
1. HIV neutralization data
2. H3N2 influenza HI assay data (Smith et al. 2004)

We conduct 20-fold cross-validation and evaluate performance using multiple metrics including mean absolute error (MAE) and Completeness.

You will need to find the optimal parameters for Topolow first. You can either use parameter fitting scripts to run sufficient number of Monte Carlo simulations on your computers, or use the results of simulations we have provided on Github (the csv files used in this script), or use the parameters provided below:

h3n2_topolow_params <- list(
    N = 4,
    k0 = 14.76214,
    cooling_rate = 0.03641074, 
    c_repulsion = 0.002943064
  )

hiv_topolow_params <- list(
    N = 2,
    k0 = 3.550036,
    cooling_rate = 0.04130713, 
    c_repulsion = 0.0007038619
  )
  
denv_topolow_params <- list(
    N = 10,
    k0 = 7.1,
    cooling_rate = 0.01232407,
    c_repulsion = 0.03830152
  )


## Setup

First, we'll load required packages and set parameters:

```{r}
library(topolow)
library(Racmacs)
library(data.table)
library(dplyr)
library(parallel)
library(ggplot2)
library(tidyr)
library(gridExtra)
library(cowplot)

# Parameters
opt_setting <- list(
  n_folds = 20,
  max_topolow_iter = 500,
  topolow_opt_rounds = 1,
  racmacs_opt_rounds = 500,
  num_cores = 7
)

# Setup output directory
output_dir <- "comparison_results"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

# Create output directories if they don't exist
coords_dir <- file.path(output_dir, "coordinates")  
plots_dir <- file.path(output_dir, "plots")
for (dir in c(coords_dir, plots_dir)) {
  if (!dir.exists(dir)) {
    dir.create(dir, recursive = TRUE)
  }
}
```

## Load and Process Data

Load and prepare both datasets:

```{r}
# Combine the two files downloaded from Los Alamos website:
data("hiv_titers")

data("hiv_viruses")

# Add meta data
hiv_viruses <- hiv_viruses %>%
  dplyr::select(c("Virus.name", "Country", "Subtype", "Year"))

hiv_titers <- hiv_titers %>% 
  dplyr::left_join(hiv_viruses, by = join_by(Virus == Virus.name)) %>%
  dplyr::select(c("Antibody", "Virus", "Country", "Subtype", "Year", "IC50")) %>% 
  dplyr::rename("virusYear" = "Year")

hiv_titers <- na.omit(hiv_titers)

hiv_titers <- hiv_titers %>% dplyr::filter(IC50 != "")

hiv_titers <- hiv_titers %>% dplyr::filter(Subtype %in% c("B", "C")) #, "01_AE", "A1", "G", "07_BC", "02_AG", "D", "A1D", "02A1"

hiv_titers$IC50 <- clean_data(hiv_titers$IC50, take_log=TRUE, k=2) # Base of log is 2; log is temporarily done only for outlier detection
hiv_titers <- na.omit(hiv_titers)

# Sort the dataset based on the "year" column
hiv_titers <- hiv_titers[order(hiv_titers$virusYear), ]

# Save the merged and prepared raw data into a csv:
write.csv(hiv_titers, "data_files/hiv_assay_full.csv")

# Load and process HIV data
hiv_results <- process_antigenic_data(
  file_path = "data_files/hiv_assay_full.csv",
  antigen_col = "Virus",
  serum_col = "Antibody", 
  value_col = "IC50",
  is_titer = FALSE,
  base = 2,
  scale_factor = 1,
  metadata_cols = c("Subtype", "Country")
)

hiv_long <- hiv_results$long

# Create filtered dataset
create_filtered_dataset <- function(data, optimal_cutoff, insufficient_thresh) {
  # Find top viruses
  top_viruses <- data %>%
    group_by(virusYear, Virus) %>%
    summarise(n_sera = n_distinct(Antibody), .groups = 'drop') %>%
    group_by(virusYear) %>%
    filter(n_sera > insufficient_thresh) %>%
    slice_max(order_by = n_sera, n = optimal_cutoff)
  
  # Find top sera
  top_sera <- data %>%
    group_by(virusYear, Antibody) %>%
    summarise(n_virus = n_distinct(Virus), .groups = 'drop') %>%
    group_by(virusYear) %>%
    filter(n_virus > insufficient_thresh) %>%
    slice_max(order_by = n_virus, n = optimal_cutoff)
  
  # Create filtered dataset
  filtered_data <- data %>%
    semi_join(top_viruses, by = c("virusYear", "Virus")) %>%
    semi_join(top_sera, by = c("virusYear", "Antibody"))
  
  return(filtered_data)
}

# Create filtered dataset with optimal cutoff=8
insufficient_thresh = 5
optimal_cutoff = 11
filtered_data <- create_filtered_dataset(hiv_long, optimal_cutoff, insufficient_thresh)

# Remove pairs with insufficient measurements (< 3 unique partners)
# Count unique partners for each Antibody and Virus
pairing_counts <- list(
  antibodies = filtered_data %>%
    group_by(Antibody) %>%
    summarise(n_partners = n_distinct(Virus)) %>%
    filter(n_partners >= 3),
  
  viruses = filtered_data %>%
    group_by(Virus) %>%
    summarise(n_partners = n_distinct(Antibody)) %>%
    filter(n_partners >= 3)
)

# Filter data to keep only entries with sufficient partners
filtered_data <- filtered_data %>%
  filter(Antibody %in% pairing_counts$antibodies$Antibody,
         Virus %in% pairing_counts$viruses$Virus)

write.csv(filtered_data, "data_files/hiv_filtered_long_data.csv", row.names = FALSE)

hiv_matrix <- long_to_matrix(filtered_data,
                            chnames = "Virus",
                            rnames = "Antibody", 
                            values_column = "distance",
                            rc = FALSE,
                            sort = TRUE)
```

```{r}
# Count the % of NA values
total_elements <- length(hiv_matrix)
na_count <- sum(is.na(hiv_matrix))
missing_percentage <- (na_count / total_elements) * 100
cat("Percentage of missing values in HIV matrix:", round(missing_percentage, 2), "%\n")
```


```{r}
# Load and process H3N2 data of Smith et al 2004
data(h3n2_data)

write.csv(h3n2_data, "data_files/h3n2_data.csv", row.names = FALSE)

h3n2_results <- process_antigenic_data(
  file_path = "data_files/h3n2_data.csv",
  antigen_col = "virusStrain",
  serum_col = "serumStrain",
  value_col = "titer", 
  is_titer = TRUE,
  base = 2, 
  scale_factor = 10,
  metadata_cols = c("virusYear", "serumYear", "cluster", "color")
)
h3n2_long <- h3n2_results$long
h3n2_matrix <- h3n2_results$matrix
```

```{r}
# Count the % of NA values
total_elements <- length(h3n2_matrix)
na_count <- sum(is.na(h3n2_matrix))
missing_percentage <- (na_count / total_elements) * 100
cat("Percentage of missing values in H3N2 matrix:", round(missing_percentage, 2), "%\n")
```

DENV data originally published by https://doi.org/10.7554/eLife.42496 , 
we use it, with no changes, in an example use case of Topolow.

```{r}
# Load and process Denv data of Katzelnick et al 2015 (also in Bell et al 2019)
denv_data <- read.csv("data_files/DENV_titers.csv")
# Extract year from rownames - assuming format like "V/strain/year" or "S/strain/year"
denv_data$virusYear <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", denv_data$virus_strain))
denv_data$serumYear <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", denv_data$serum_strain))

# extract serotype cluster (everything before the first “/”)
denv_data$cluster    <- sub("/.*", "", denv_data$virus_strain)

# define a named color vector matching your project palette
cluster_colors <- c(
  DENV1 = "#ff7f00",  # orange
  DENV2 = "#1f78b4",  # blue 
  DENV3 = "#33a02c",  # green
  DENV4 = "#e31a1c"   # red
)

# assign the corresponding color to each row
denv_data$color <- cluster_colors[ denv_data$cluster ]

write.csv(denv_data, "data_files/DENV_titers.csv", row.names = FALSE)


denv_data_results <- process_antigenic_data(
  file_path = "data_files/DENV_titers.csv",
  antigen_col = "virus_strain",
  serum_col = "serum_strain",
  value_col = "titer", 
  is_titer = TRUE,
  base = 2, 
  scale_factor = 10,
  metadata_cols = c("virusYear", "serumYear", "cluster", "color")
)

# Extract distance matrix
denv_distance_matrix <- denv_data_results$matrix
# Quick look at the processed data
denv_long <- denv_data_results$long
head(denv_long)
```

```{r}
# Count the % of NA values
total_elements <- length(denv_distance_matrix)
na_count <- sum(is.na(denv_distance_matrix))
missing_percentage <- (na_count / total_elements) * 100
cat("Percentage of missing values in DENV matrix:", round(missing_percentage, 2), "%\n")
```

## Load Optimal Parameters

Load and combine parameter chains for both datasets:

```{r}
# HIV parameter chains
hiv_chains <- c(
  "model_parameters/HIV_BC_AMC202_model_parameters.csv",
  "model_parameters/HIV_BC_AMC204_model_parameters.csv",
  "model_parameters/HIV_BC_AMC205_model_parameters.csv",
  "model_parameters/HIV_BC_AMC206_model_parameters.csv"
)

# H3N2 parameter chains  
h3n2_chains <- c(
  "model_parameters/H3N2_2003_data_AMC201_model_parameters.csv",
  "model_parameters/H3N2_2003_data_AMC202_model_parameters.csv",
  "model_parameters/H3N2_2003_data_AMC203_model_parameters.csv",
  "model_parameters/H3N2_2003_data_AMC205_model_parameters.csv"
)

denv_chains <- c(
  "model_parameters/denv_data_AMC101_model_parameters.csv",
  "model_parameters/denv_data_AMC102_model_parameters.csv",
  "model_parameters/denv_data_AMC103_model_parameters.csv",
  "model_parameters/denv_data_AMC104_model_parameters.csv",
  "model_parameters/denv_data_AMC105_model_parameters.csv"
)

# Function to read and clean one CSV
clean_and_overwrite <- function(file_path) {
  # 1. Read every column in as character
  df <- read.csv(file_path, stringsAsFactors = FALSE, colClasses = "character")
  
  # 2. For each column: remove any literal double‐quotes and coerce to numeric
  df[] <- lapply(df, function(col) {
    # strip all " characters (in case they were embedded in the field)
    col_stripped <- gsub('"', "", col, fixed = TRUE)
    # convert the result to numeric
    as.numeric(col_stripped)
  })
  
  # 3. Write back to the same path, preserving only the data
  write.csv(df, file = file_path, row.names = FALSE)
}

# 4. Apply to every file
invisible(lapply(hiv_chains, clean_and_overwrite))
invisible(lapply(h3n2_chains, clean_and_overwrite))
invisible(lapply(denv_chains, clean_and_overwrite))

# Function to get optimal parameters from chains
get_optimal_topolow_params <- function(chain_files) {
  # Read and combine chains
  chains <- do.call(rbind, lapply(chain_files, read.csv))
  
  # Clean and filter
  chains <- chains %>%
    filter(!is.na(NLL) & !is.na(Holdout_MAE) & 
             is.finite(NLL) & is.finite(Holdout_MAE)) %>%
    na.omit()
  
  chains <- chains[chains$log_N >= log(2),]
  
  # Apply clean_data to all columns of the dataframe
  chains <- as.data.frame(lapply(chains, clean_data, k = 3.5))
  chains <- na.omit(chains)

  # Get best parameters
  best_params <- chains[which.min(chains$Holdout_MAE),]
  
  list(
    N = round(exp(as.numeric(best_params$log_N))),
    k0 = exp(as.numeric(best_params$log_k0)),
    cooling_rate = exp(as.numeric(best_params$log_cooling_rate)), 
    c_repulsion = exp(as.numeric(best_params$log_c_repulsion))
  )
}

# Get optimal parameters for each dataset
hiv_topolow_params <- get_optimal_topolow_params(hiv_chains)
h3n2_topolow_params <- get_optimal_topolow_params(h3n2_chains)
denv_topolow_params <- get_optimal_topolow_params(denv_chains)

print("HIV optimal parameters:")
print(hiv_topolow_params)
print("\nH3N2 optimal parameters:")
print(h3n2_topolow_params)
print("DENV optimal parameters:")
print(denv_topolow_params)
```


```{r}
datasets <- list(
  H3N2 = list(
    matrix = h3n2_matrix,
    topolow_params = h3n2_topolow_params,
    racmacs_dim = 4, # Read from plot racmacs_dimension_analysis.pdf generated below
    base = 2,        # For titer conversion
    tens = 10,       # For titer conversion
    has_clusters = TRUE
  ),
  HIV = list(
    matrix = hiv_matrix,
    topolow_params = hiv_topolow_params,
    racmacs_dim = 2, # Read from plot racmacs_dimension_analysis.pdf generated below
    base = 2,        # For titer conversion
    tens = 1,        # For titer conversion
    has_clusters = FALSE
  ),
  DENV = list(
    matrix = denv_distance_matrix,
    topolow_params = denv_topolow_params,
    racmacs_dim = 3, # Read from plot racmacs_dimension_analysis.pdf generated below
    base = 2,        # For titer conversion
    tens = 10,       # For titer conversion
    has_clusters = TRUE
  )
)

```


## Find optimal dimensions for RACMACS
```{r}
# Find optimal dimensionality for MDS/RACMACS
dimensions_to_test <- 2:10  # Test dimensions from 1D to 10D

# Create output directories if they don't exist
coords_dir <- file.path(output_dir, "coordinates")  
plots_dir <- file.path(output_dir, "plots")
for (dir in c(coords_dir, plots_dir)) {
  if (!dir.exists(dir)) {
    dir.create(dir, recursive = TRUE)
  }
}
# Initialize dimension-specific results storage
dim_results <- data.table(
  Dimension = integer(),
  MAE = numeric(),
  Completeness = numeric(),
  Dataset = character(),
  Algorithm = character(),
  stringsAsFactors = FALSE
)

for(dataset_name in names(datasets)) { #
  # Get dataset
  distance_matrix <- datasets[[dataset_name]]$matrix
  
  # Create CV folds
  matrix_list <- create_cv_folds(
    truth_matrix = distance_matrix,
    n_folds = opt_setting$n_folds
  )
  
  # Run each dimension
  for(dim in dimensions_to_test) {
    message(sprintf("Processing %s dataset with dimension %d", dataset_name, dim))
    
    # Storage for this dimension's folds
    fold_mae <- numeric(opt_setting$n_folds)
    fold_Completeness <- numeric(opt_setting$n_folds)
    
    # Run comparison for each fold
    for(i in seq_len(opt_setting$n_folds)) {
      # Get matrices for this fold
      truth_matrix <- matrix_list[[i]][[1]]
      input_matrix <- matrix_list[[i]][[2]]
      
      # Convert to titer format based on dataset
      if(dataset_name %in% c("H3N2", "DENV")) {
        titer_table <- dist_to_titer_table(input_matrix, base=2, tens=10)
      } else {
        titer_table <- dist_to_titer_table(input_matrix, tens=1)
      }
      
      # Run RACMACS with this dimension
      map <- create_and_optimize_RACMACS_map(
        titer_table = titer_table,
        dim = dim,  # Set the dimension
        optimization_number = opt_setting$racmacs_opt_rounds,
        num_cores = opt_setting$num_cores
      )
      
      # Save coordinates
      coords_file <- file.path(coords_dir, 
                              paste0(dataset_name, "_RACMACS_dim", dim, "_fold", i, ".csv"))
      save.coords(map, filename = coords_file,
                 optimization_number = 1, antigens = TRUE, sera = TRUE)
      
      # Process RACMACS results
      positions_racmacs <- read.csv(coords_file)
      positions_racmacs$name <- ifelse(
        positions_racmacs$type == "antigen",
        paste0("V/", positions_racmacs$name),
        paste0("S/", positions_racmacs$name)
      )
      
      rownames(positions_racmacs) <- positions_racmacs$name
      positions_racmacs <- positions_racmacs[,3:ncol(positions_racmacs)]
      
      # Calculate distances
      p_dist_mat <- coordinates_to_matrix(as.matrix(positions_racmacs))
      
      # Calculate errors
      racmacs_errors <- error_calculator_comparison(
        p_dist_mat = p_dist_mat,
        truth_matrix = truth_matrix,
        input_matrix = input_matrix
      )
      
      # Store this fold's metrics
      fold_mae[i] <- mean(abs(racmacs_errors$report_df$OutSampleError), na.rm = TRUE)
      fold_Completeness[i] <- racmacs_errors$Completeness
    }
    
    # Calculate averages across folds
    mean_mae <- mean(fold_mae, na.rm = TRUE)
    mean_Completeness <- mean(fold_Completeness, na.rm = TRUE)
    
    # Store dimension results
    dim_results <- rbind(
      dim_results,
      data.table(
        Dimension = dim,
        MAE = mean_mae,
        Completeness = mean_Completeness * 100,  # Convert to percentage
        Dataset = dataset_name,
        Algorithm = "MDS"
      )
    )
  }
}

# Save dimension results
write.csv(dim_results, file.path(output_dir, "racmacs_dimension_results_denv.csv"))
```


## RACMACS error vs dimension plots
```{r}
# Create dual axis plots
plot_dimension_results <- function(results, dataset_name) {
  # Filter results for this dataset
  dataset_results <- results[results$Dataset == dataset_name,]
  # Calculate the scaled position for 95% Completeness
  scaled_95_percent <- 95/max(dataset_results$Completeness)*max(dataset_results$MAE)
  
  # Create plot with dual y-axes
  ggplot(dataset_results, aes(x = Dimension)) +
    # MAE line
    geom_line(aes(y = MAE, color = "Validation MAE"), size = 1) +
    geom_point(aes(y = MAE, color = "Validation MAE"), size = 2) +
    # Completeness line (scaled to match MAE range for dual axis)
    geom_line(aes(y = Completeness/max(Completeness)*max(MAE), color = "Completeness"), size = 1) +
    geom_point(aes(y = Completeness/max(Completeness)*max(MAE), color = "Completeness"), size = 2) +
    # Add horizontal line at 95% Completeness
    geom_hline(yintercept = scaled_95_percent, linetype = "dashed", color = "blue", alpha = 0.7) +
    # Add text label for 95% Completeness line
    annotate("text", x = max(dataset_results$Dimension) * 0.6, 
             y = scaled_95_percent * 1.04, 
             label = "Completeness = 95%", 
             color = "blue", hjust = 0, size = 2.4) +
    # Set up axes
    scale_y_continuous(
      name = "Validation MAE",
      sec.axis = sec_axis(~ . * max(dataset_results$Completeness)/max(dataset_results$MAE), 
                          name = "Completeness (%)")) +
    scale_color_manual(values = c("Validation MAE" = "red", "Completeness" = "blue"),
                       name = "Metric") +
    labs(#title = paste(dataset_name, "Dataset"),
         x = "Dimension") +
    theme_minimal() +
    theme(
      panel.grid.minor.y = element_line(size = 0.25,
                                          linetype = 1),
      legend.position = "bottom",
      legend.text = element_text(size = 7),
      legend.title = element_text(size = 7),
      plot.title = element_text(hjust = 0.5, size = 9),
      axis.title = element_text(size = 8),
      axis.text = element_text(size = 7)
    )
}

dim_results <- read.csv(file.path(output_dir, "racmacs_dimension_results.csv"))
# Generate individual plots
h3n2_plot <- plot_dimension_results(dim_results, "H3N2")
hiv_plot <- plot_dimension_results(dim_results, "HIV")
denv_plot <- plot_dimension_results(dim_results, "DENV")

# Combine plots side by side
combined_plot <- plot_grid(
  h3n2_plot, hiv_plot, denv_plot,
  labels = c("A. H3N2 data", "B. HIV data", "C. DENV"),
  label_size = 7,
  nrow = 1,
  align = 'h',
  axis = 'tb'
)

# Save the combined plot
cowplot::save_plot(
  file.path(plots_dir, "racmacs_dimension_analysis.pdf"),
  combined_plot,
  ncol = 3,
  nrow = 1,
  base_width = 3.26772*0.9, 
  base_height = 3
)
```


## Finding coordinates
```{r eval=FALSE}
### Part 1: Find and save coordinates ###
message("\nFinding coordinates for all datasets...")

for (dataset_name in names(datasets) ) { #
  dataset <- datasets[[dataset_name]]
  distance_matrix <- dataset$matrix
  topolow_params <- dataset$topolow_params
  racmacs_dim <- dataset$racmacs_dim
  
  message(sprintf("\nProcessing %s dataset...", dataset_name))
  
  ######################## Run Topolow
  topo_result <- tryCatch({
    create_topolow_map(
      distance_matrix = distance_matrix,
      ndim = topolow_params$N,
      mapping_max_iter = opt_setting$max_topolow_iter,
      relative_epsilon = 1e-10,
      convergence_counter = 3,
      k0 = topolow_params$k0,
      cooling_rate = topolow_params$cooling_rate,
      c_repulsion = topolow_params$c_repulsion,
      write_positions_to_csv = FALSE,
      verbose = TRUE
    )
  }, error = function(e) {
    warning(sprintf("! Error in Topolow optimization for %s: %s", 
                   dataset_name, e$message))
    return(NULL)
  })
  
  if (!is.null(topo_result)) {
    coords_file <- file.path(coords_dir, 
                           sprintf("topolow_%s_coords.csv", dataset_name))
    positions_df <- as.data.frame(topo_result$positions)
    write.csv(positions_df, coords_file, row.names = TRUE)
  }
  
  
  #################### Run RACMACS
  titer_table <- dist_to_titer_table(distance_matrix, 
                                    base = dataset$base,
                                    tens = dataset$tens)
  
  map <- create_and_optimize_RACMACS_map(
    titer_table = titer_table,
    dim = racmacs_dim,
    optimization_number = opt_setting$racmacs_opt_rounds,
    num_cores = opt_setting$num_cores
  )
  
  coords_file <- file.path(coords_dir, 
                         sprintf("racmacs_%s_coords.csv", dataset_name))
  save.coords(map, filename = coords_file,
             optimization_number = 1, antigens = TRUE, sera = TRUE)
}
```



## Create antigenic maps
### Setup
```{r}
# Create visualization configurations
annotation_config <- new_annotation_config(
  size = 4.9,                       # Text size
  color = "black",                  # Text color
  #fontface = "bold",               # Text style
  outline_size = 0.3                # Size of point outlines
)

dim_config <- new_dim_reduction_config(
  method = "pca",
  n_components = 2,
  scale = FALSE
)

sc = 1
aesthetic_config <- new_aesthetic_config(
  point_shapes = c(antigen = 16, antiserum = 5),
  point_size = 1.5,
  point_alpha = 0.65,
  color_palette = "c25", 
  gradient_colors = list(low = "blue", high = "red"),
  title_size = 7*sc,
  subtitle_size = 7*sc,
  axis_title_size = 7*sc,
  axis_text_size = 6*sc,
  show_legend = FALSE,
  legend_position = "none",
  show_title = FALSE,
  show_labels = FALSE,
  arrow_head_size=0.1,
  arrow_alpha = 0.55
)

layout_config <- new_layout_config(
  width = 3.26772*0.47,
  height = 3,
  dpi = 300,
  x_limits = c(-8, 8),
  y_limits = c(-18, 18),
  reverse_x = -1, 
  reverse_y = 1,
  plot_margin = margin(0.05, 0.05, 0.05, 0.05, "cm"),
  save_format = "pdf",
  arrow_plot_threshold = 2.5
)
```


### H3N2
```{r}
### Create plots from saved coordinates ###

# Get H3N2 metadata once
h3n2_metadata <- NULL
if (any(sapply(datasets, function(x) x$has_clusters))) {
  h3n2_metadata <- h3n2_long %>%
    select(virusStrain, cluster, color) %>%
    distinct()
}

#Code below combines H3N2 maps in a 2-panel figure for the paper:

# First verify files exist and check their content
topo_file <- file.path(coords_dir, "topolow_H3N2_coords.csv")
rac_file <- file.path(coords_dir, "racmacs_H3N2_coords.csv")

if (!file.exists(topo_file)) {
  stop("TopoLow coordinates file not found at: ", topo_file)
}
if (!file.exists(rac_file)) {
  stop("RACMACS coordinates file not found at: ", rac_file)
}

# Read and process TopoLow coordinates
positions_topolow <- read.csv(topo_file)
if (nrow(positions_topolow) == 0) {
  stop("TopoLow coordinates file is empty")
}

# Process TopoLow coordinates
positions_topolow$name <- positions_topolow$X  # Restore rownames
positions_topolow$X <- NULL
positions_topolow$antigen <- startsWith(positions_topolow$name, "V/")
positions_topolow$antiserum <- startsWith(positions_topolow$name, "S/")
positions_topolow$year <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", positions_topolow$name))
positions_topolow$name <- sub("^[VS]/", "", positions_topolow$name)

# Add cluster information
if (!exists("h3n2_metadata")) {
  stop("h3n2_metadata not found. Please ensure it's loaded.")
}
positions_topolow <- merge(positions_topolow, h3n2_metadata, 
                         by.x = "name", by.y = "virusStrain", all.x = TRUE)
positions_topolow <- na.omit(positions_topolow)

# Read and process RACMACS coordinates
positions_racmacs <- read.csv(rac_file)
if (nrow(positions_racmacs) == 0) {
  stop("RACMACS coordinates file is empty")
}

# Process RACMACS coordinates
positions_racmacs$name <- ifelse(
  positions_racmacs$type == "antigen",
  paste0("V/", positions_racmacs$name),
  paste0("S/", positions_racmacs$name)
)
positions_racmacs$antigen <- startsWith(positions_racmacs$name, "V/")
positions_racmacs$antiserum <- startsWith(positions_racmacs$name, "S/")
positions_racmacs$year <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", positions_racmacs$name))
positions_racmacs$name <- sub("^[VS]/", "", positions_racmacs$name)
positions_racmacs$V1 <- positions_racmacs$X
positions_racmacs$V2 <- positions_racmacs$X.1
positions_racmacs$V3 <- positions_racmacs$X.2
positions_racmacs$V4 <- positions_racmacs$X.3

# Add cluster information
positions_racmacs <- merge(positions_racmacs, h3n2_metadata,
                         by.x = "name", by.y = "virusStrain", all.x = TRUE)
positions_racmacs <- na.omit(positions_racmacs)

# Print dimensions to verify data
print(dim(positions_topolow))
print(dim(positions_racmacs))


library(ape)
phylo_tree <- read.tree("data_files/H3N2_phylo_groupings_rooted.nwk")
positions_topolow$name <- toupper(positions_topolow$name)

#### Create the individual plots

# Add text labels to topolow
text_labels_topolow <- data.frame(
  x = c( 2.5, -4.5, -4, 2.9, -3.6, 5.3, -5, 5.3, -4, 2, -3),
  y = c( 17, 13, 9, 7.7, 5.6, 1, -2.7, -5, -8, -11, -14.5), # Adjust y for label positioning
  label = c( "HK68", "EN72", "VI75", "TX77", "BK79", "SI87", "BE89", "BE92", "WU95", "SY97", "FU02")
)

layout_config$reverse_x <- -1
topolow_plot <- plot_cluster_mapping(
  positions_topolow,
  ndim = datasets$H3N2$topolow_params$N,
  dim_config = dim_config,
  annotation_config = annotation_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config,
  draw_arrows=TRUE,
  annotate_arrows = FALSE,
  phylo_tree = phylo_tree,
  show_one_arrow_per_cluster = TRUE
) + 
  ggtitle("TopoLow") + 
  geom_text(data = text_labels_topolow, 
            aes(x = x, y = y, label = label, colour = label),
            size = annotation_config$size / ggplot2::.pt)


layout_config$reverse_x <- 1
racmacs_plot <- plot_cluster_mapping(
  positions_racmacs,
  ndim = datasets$H3N2$racmacs_dim,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config
) + ggtitle("MDS")

# Combine plots
combined_plot <- plot_grid(
  topolow_plot, racmacs_plot,
  labels = c("A", "B"),
  label_size = 6,
  nrow = 1,
  align = 'h',
  axis = 'tb'
)

# Save combined plot
cowplot::save_plot(
  file.path(plots_dir, "combined_H3N2_clusters.pdf"),
  combined_plot,
  ncol = 2,
  nrow = 1,
  base_width = 3.26772*0.5,
  base_height = layout_config$height
)
```

A larger map with all arrows and annotations
```{r}
layout_config$width = 3.26772*1.5
layout_config$height = 6*1.5
layout_config$arrow_plot_threshold = 0.0
layout_config$reverse_x <- -1

aesthetic_config$show_legend = TRUE
aesthetic_config$legend_position = "right"


topolow_plot <- plot_cluster_mapping(
  positions_topolow,
  ndim = datasets$H3N2$topolow_params$N,
  dim_config = dim_config,
  annotation_config = annotation_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config,
  draw_arrows=TRUE,
   annotate_arrows = FALSE,
   phylo_tree = phylo_tree,
  show_one_arrow_per_cluster = FALSE,
  cluster_legend_order = c( "HK68", "EN72", "VI75", "TX77", "BK79", "SI87", "BE89", "BE92", "WU95", "SY97", "FU02")
)
```

### HIV
```{r}
### Create plots from saved coordinates ###

# Get HIV metadata once
hiv_metadata <- NULL
hiv_metadata <- hiv_long %>%
  select(Virus, Subtype, virusYear) %>%
  distinct()

# Add  year
hiv_metadata <- hiv_metadata %>% 
  dplyr::rename("year" = "virusYear")

# First verify files exist and check their content
topo_file <- file.path(coords_dir, "topolow_HIV_coords.csv")
rac_file <- file.path(coords_dir, "racmacs_HIV_coords.csv")

if (!file.exists(topo_file)) {
  stop("TopoLow coordinates file not found at: ", topo_file)
}
if (!file.exists(rac_file)) {
  stop("RACMACS coordinates file not found at: ", rac_file)
}

# Read and process TopoLow coordinates
positions_topolow <- read.csv(topo_file)
if (nrow(positions_topolow) == 0) {
  stop("TopoLow coordinates file is empty")
}

# Process TopoLow coordinates
positions_topolow$name <- positions_topolow$X  # Restore rownames
positions_topolow$X <- NULL
positions_topolow$antigen <- startsWith(positions_topolow$name, "V/")
positions_topolow$antiserum <- startsWith(positions_topolow$name, "S/")
#positions_topolow$year <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", positions_topolow$name))
positions_topolow$name <- sub("^[VS]/", "", positions_topolow$name)

# Add cluster information
if (!exists("hiv_metadata")) {
  stop("hiv_metadata not found. Please ensure it's loaded.")
}
positions_topolow <- merge(positions_topolow, hiv_metadata, 
                         by.x = "name", by.y = "Virus", all.x = TRUE)
positions_topolow <- na.omit(positions_topolow)
positions_topolow$cluster <- positions_topolow$Subtype

# Read and process RACMACS coordinates
positions_racmacs <- read.csv(rac_file)
if (nrow(positions_racmacs) == 0) {
  stop("RACMACS coordinates file is empty")
}

# Process RACMACS coordinates
positions_racmacs$name <- ifelse(
  positions_racmacs$type == "antigen",
  paste0("V/", positions_racmacs$name),
  paste0("S/", positions_racmacs$name)
)
positions_racmacs$antigen <- startsWith(positions_racmacs$name, "V/")
positions_racmacs$antiserum <- startsWith(positions_racmacs$name, "S/")
#positions_racmacs$year <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", positions_racmacs$name))
positions_racmacs$name <- sub("^[VS]/", "", positions_racmacs$name)
positions_racmacs$V1 <- positions_racmacs$X
positions_racmacs$V2 <- positions_racmacs$X.1

# Add cluster information
positions_racmacs <- merge(positions_racmacs, hiv_metadata,
                         by.x = "name", by.y = "Virus", all.x = TRUE)
positions_racmacs <- na.omit(positions_racmacs)
positions_racmacs$cluster <- positions_racmacs$Subtype

# Print dimensions to verify data
print(dim(positions_topolow))
print(dim(positions_racmacs))

###### PLOT

dim_config <- new_dim_reduction_config(
  method = "pca",
  n_components = 2,
  scale = FALSE
)

layout_config <- new_layout_config(
  width = 3.26772*0.47,
  height = 1.9,
  dpi = 300,
  x_limits = c(-3.56, 2.8),
  #y_limits = c(-3, 4),
  plot_margin = margin(0.05, 0.05, 0.05, 0.05, "cm"),
  save_format = "pdf",
  arrow_plot_threshold = 1
)

aesthetic_config <- new_aesthetic_config(
  point_shapes = c(antigen = 16, antiserum = 4),
  point_size = 1.5,
  point_alpha = 0.65,
  title_size = 7,
  subtitle_size = 6,
  axis_title_size = 6,
  axis_text_size = 6,
  legend_text_size =  6,
  legend_title_size = 6,
  show_legend = FALSE,
  legend_position = "none",
  show_title = FALSE,
  arrow_head_size=0.11
)

annotation_config <- new_annotation_config(
  size = 4.9,                              # Text size
  color = "black",                         # Text color
  fontface = "bold",                       # Text style
  outline_size = 0.4                       # Size of point outlines
)

# Add text labels to topolow
text_labels_topolow <- data.frame(
  x = c( -2.2, 2.3),
  y = c( -2.2, 1.1), # Adjust y for label positioning
  label = c( "C", "B")
)

phylo_tree_hiv <- read.tree("data_files/HIV1BC_phylo_groupings_rooted.nwk")
positions_topolow$name <- toupper(positions_topolow$name)

topolow_plot_hiv <- plot_cluster_mapping(
  positions_topolow,
  ndim = datasets$HIV$topolow_params$N,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config,
  show_shape_legend = FALSE,
  draw_arrows=TRUE,
  annotate_arrows = FALSE,
  phylo_tree = phylo_tree_hiv
  #cluster_legend_title = "Subtype"
) + 
  geom_text(data = text_labels_topolow, 
            aes(x = x, y = y, label = label, colour = label),
            size = annotation_config$size / ggplot2::.pt,
            fontface = annotation_config$fontface
            )
topolow_plot_hiv
# # Create the individual plots
# topolow_plot <- plot_cluster_mapping(
#   positions_topolow,
#   ndim = datasets$HIV$topolow_params$N,
#   dim_config = dim_config,
#   aesthetic_config = aesthetic_config,
#   layout_config = layout_config
# ) + ggtitle("TopoLow")
# 
# racmacs_plot <- plot_cluster_mapping(
#   positions_racmacs,
#   ndim = datasets$HIV$racmacs_dim,
#   dim_config = dim_config,
#   aesthetic_config = aesthetic_config,
#   layout_config = layout_config
# ) + ggtitle("RACMACS")
# 
# # Combine plots
# combined_plot <- plot_grid(
#   topolow_plot, racmacs_plot,
#   labels = c("A", "B"),
#   label_size = 8,
#   nrow = 1,
#   align = 'h',
#   axis = 'tb'
# )
# 
# # Save combined plot
# save_plot(
#   file.path(plots_dir, "combined_HIV_clusters.pdf"),
#   combined_plot,
#   ncol = 2,
#   nrow = 1,
#   base_width = 3.26772*0.5,
#   base_height = layout_config$height
# )
```


A larger map with all arrows and annotations
```{r}
layout_config$width = 3.26772*1.7
layout_config$height = 3.9*1.7
layout_config$arrow_plot_threshold = 0.0

aesthetic_config$show_legend = TRUE
aesthetic_config$legend_position = "right"

topolow_plot_hiv <- plot_cluster_mapping(
  positions_topolow,
  ndim = datasets$HIV$topolow_params$N,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config,
  show_shape_legend = TRUE,
  draw_arrows=TRUE,
  annotate_arrows = FALSE,
  phylo_tree = phylo_tree_hiv,
  show_one_arrow_per_cluster = FALSE,
  cluster_legend_title = "Subtype"
)

```


### DENV

```{r}
topo_file <- file.path(coords_dir, "topolow_DENV_coords.csv")
rac_file <- file.path(coords_dir, "racmacs_DENV_coords.csv")

if (!file.exists(topo_file)) {
  stop("TopoLow coordinates file not found at: ", topo_file)
}
if (!file.exists(rac_file)) {
  stop("RACMACS coordinates file not found at: ", rac_file)
}

positions_topolow_denv <- read.csv(topo_file)
positions_topolow_denv$name <- positions_topolow_denv$X
positions_topolow_denv$X <- NULL

# Add antigen/antiserum indicators based on rownames
positions_topolow_denv$antigen <- startsWith(positions_topolow_denv$name, "V/")
positions_topolow_denv$antiserum <- startsWith(positions_topolow_denv$name, "S/")

# Extract year from rownames - assuming format like "V/strain/year" or "S/strain/year"
positions_topolow_denv$year <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", positions_topolow_denv$name))

# Clean names to match with metadata
positions_topolow_denv$name <- sub("^S/", "", positions_topolow_denv$name)
positions_topolow_denv$name <- sub("^V/", "", positions_topolow_denv$name)

# Join with original data to get cluster and color information
denv_metadata <- denv_data_results$long %>%
  select(virus_strain, cluster, color) %>%
  distinct()

positions_topolow_denv <- positions_topolow_denv %>%
  left_join(denv_metadata, by = c("name" = "virus_strain"))

# Remove any rows that didn't get metadata matched
positions_topolow_denv <- na.omit(positions_topolow_denv)

# Read and process RACMACS coordinates
positions_racmacs <- read.csv(rac_file)
if (nrow(positions_racmacs) == 0) {
  stop("RACMACS coordinates file is empty")
}

# Process RACMACS coordinates
positions_racmacs$name <- ifelse(
  positions_racmacs$type == "antigen",
  paste0("V/", positions_racmacs$name),
  paste0("S/", positions_racmacs$name)
)
positions_racmacs$antigen <- startsWith(positions_racmacs$name, "V/")
positions_racmacs$antiserum <- startsWith(positions_racmacs$name, "S/")
#positions_racmacs$year <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", positions_racmacs$name))
positions_racmacs$name <- sub("^[VS]/", "", positions_racmacs$name)
positions_racmacs$V1 <- positions_racmacs$X
positions_racmacs$V2 <- positions_racmacs$X.1
positions_racmacs$V3 <- positions_racmacs$X.2

# Extract year from rownames - assuming format like "V/strain/year" or "S/strain/year"
positions_racmacs$year <- as.numeric(sub(".*/([0-9]{4}).*", "\\1", positions_racmacs$name))

# Add cluster information
positions_racmacs <- merge(positions_racmacs, denv_metadata,
                         by.x = "name", by.y = "virus_strain", all.x = TRUE)

positions_racmacs <- na.omit(positions_racmacs)

# Print dimensions to verify data
print(dim(positions_topolow_denv))
print(dim(positions_racmacs))

dim_config <- new_dim_reduction_config(
  method = "pca",
  n_components = 2,
  scale = TRUE
)

annotation_config <- new_annotation_config(
  size = 4.9,                              # Text size
  color = "black",                         # Text color
  fontface = "bold",                       # Text style
  outline_size = 0.4                       # Size of point outlines
)

# Aesthetic configuration 
aesthetic_config <- new_aesthetic_config(
  point_size = 1.5,
  point_alpha = 0.6,
  point_shapes = c(antigen = 16, antiserum = 5),
  color_palette = "c25", 
  gradient_colors = list(
    low = "blue",
    high = "red"
  ),
  show_labels = FALSE,
  title_size = 7,
  subtitle_size = 6,
  axis_title_size = 6,
  axis_text_size = 6,
  show_legend = FALSE,
  legend_position = "none",
  show_title = FALSE,
  arrow_head_size=0.11,
  arrow_alpha = 0.5
)

# To mirror the maps to make them comparable with other maps set the reverse parameter to -1
layout_config <- new_layout_config(
  width = 3.26772*0.47,
  height = 1.9,
  dpi = 300,
  #x_limits = c(-3.1, 3.1),
  #y_limits = c(-3, 4),
  reverse_x = 1,
  reverse_y = 1,
  plot_margin = margin(0.05, 0.05, 0.05, 0.05, "cm"),
  save_format = "pdf",
  arrow_plot_threshold = .2
)

# Add text labels to topolow
text_labels_topolow <- data.frame(
  x = c( -2.5, -0.7, -0.4, 0),
  y = c( 1.7, 2.2, -1.8, 0.2), # Adjust y for label positioning
  label = c( "DENV1", "DENV2", "DENV3", "DENV4")
)  

library(ape)
phylo_tree <- read.tree("data_files/DENV1234_timetree.nwk")
positions_topolow_denv$name <- toupper(positions_topolow_denv$name)

# Cluster mapping
topolow_plot_denv <- plot_cluster_mapping(positions_topolow_denv, ndim = denv_topolow_params$N, 
                           aesthetic_config = aesthetic_config, 
                           layout_config = layout_config, 
                           annotation_config = annotation_config,
                           draw_arrows=TRUE,
                           annotate_arrows = FALSE,
                           phylo_tree = phylo_tree
                           ) + 
      geom_text(data = text_labels_topolow, 
            aes(x = x, y = y, label = label, colour = label),
            size = annotation_config$size / ggplot2::.pt,
            fontface = annotation_config$fontface
            )
print(topolow_plot_denv)


#### RACMACS plot
# Add text labels to topolow
text_labels_topolow <- data.frame(
  x = c( 1, -2, 0.4, 0),
  y = c( 2.7, -1, -1.8, 0.2), # Adjust y for label positioning
  label = c( "DENV1", "DENV2", "DENV3", "DENV4")
)  
layout_config$reverse_x <- -1
layout_config$reverse_y <- -1
racmacs_plot <- plot_cluster_mapping(
  positions_racmacs,
  ndim = datasets$DENV$racmacs_dim,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config
) + geom_text(data = text_labels_topolow, 
            aes(x = x, y = y, label = label, colour = label),
            size = annotation_config$size / ggplot2::.pt,
            fontface = annotation_config$fontface
            )

racmacs_plot
cowplot::save_plot(
  file.path(plots_dir, "racmacs_plot_DENV.pdf"),
  racmacs_plot,
  ncol = 1,
  nrow = 1,
  base_width = 3.26772,
  base_height = layout_config$height*2
)
```


A larger map with all arrows and annotations
```{r}
layout_config$width = 3.26772*1.3
layout_config$height = 3*1.3
layout_config$arrow_plot_threshold = 0.03
layout_config$reverse_x <- 1
layout_config$reverse_y <- 1

aesthetic_config$show_legend = TRUE
aesthetic_config$legend_position = "right"

topolow_plot_denv <- plot_cluster_mapping(positions_topolow_denv, ndim = denv_topolow_params$N, 
                           aesthetic_config = aesthetic_config, 
                           layout_config = layout_config, 
                           annotation_config = annotation_config,
                           show_shape_legend = TRUE,
                           draw_arrows=TRUE,
                           annotate_arrows = FALSE,
                           phylo_tree = phylo_tree,
                           cluster_legend_title = "Serotype"
                           ) 

```

Below we calculate the average distances between viruses of different serotypes from the input data in function avg_prefix_distance
and compare it with the distances from Topolow coordinates in function avg_intercluster_distanceto validate whether the visual distances on the map are to the scale or not. 
```{r}
library(data.table)

#’ Compute average inter‐prefix distance
#’
#’ @param data           data.frame or data.table containing at least the
#’                       columns virus_col, serum_col, and distance_col
#’ @param virus_prefix   character; prefix to match at start of virus_strain
#’ @param serum_prefix   character; prefix to match at start of serum_strain
#’ @param virus_col      name of the virus‐strain column (default "virus_strain")
#’ @param serum_col      name of the serum‐strain column (default "serum_strain")
#’ @param distance_col   name of the distance column (default "distance")
#’ @param na.rm          logical; whether to remove NA distances before averaging
#’
#’ @return               numeric; the mean of distance_col for matching rows
#’ @examples
#’ avg_prefix_distance(denv_long, "DENV1", "DENV2")
avg_prefix_distance <- function(data,
                                virus_prefix,
                                serum_prefix,
                                virus_col    = "virus_strain",
                                serum_col    = "serum_strain",
                                distance_col = "distance",
                                na.rm        = TRUE) {
  # ensure a data.table
  dt <- as.data.table(data)
  
  # convert distance column to numeric if needed
  if (!is.numeric(dt[[distance_col]])) {
    dt[, (distance_col) := as.numeric(dt[[distance_col]]) ]
  }
  
  # select only rows matching both prefixes
  subset_dt <- dt[
    startsWith(get(virus_col), virus_prefix) &
    startsWith(get(serum_col), serum_prefix)
  ]
  
  # compute and return mean distance
  mean(subset_dt[[distance_col]], na.rm = na.rm)
}

dt <- as.data.table(positions_topolow_denv)

# identify the coordinate columns
coord_cols <- paste0("V", 1:18)

avg_intercluster_distance <- function(dt, coord_cols, cluster_col, c1, c2){
  m1 <- as.matrix( dt[get(cluster_col) == c1, ..coord_cols] )
  m2 <- as.matrix( dt[get(cluster_col) == c2, ..coord_cols] )
  A  <- rowSums(m1^2)
  B  <- rowSums(m2^2)
  C  <- tcrossprod(m1, m2)
  sq <- outer(A, B, "+") - 2*C
  sq[sq < 0] <- 0
  mean(sqrt(sq))
}



avg_prefix_distance(denv_long, "DENV1", "DENV2")


avg_intercluster_distance(
  dt           = dt,
  coord_cols   = coord_cols,
  cluster_col  = "cluster",
  c1           = "DENV1",
  c2           = "DENV2"
)

```


### HIV + DENV for paper:
```{r}
# Combine plots
combined_plot <- plot_grid(
  topolow_plot_hiv, topolow_plot_denv,
  labels = c("A", "B"),
  label_size = 6,
  nrow = 1,
  align = 'h',
  axis = 'tb'
)

# Save combined plot
cowplot::save_plot(
  file.path(plots_dir, "combined_HIV_DENV.pdf"),
  combined_plot,
  ncol = 2,
  nrow = 1,
  base_width = 3.26772*0.5,
  base_height = layout_config$height
)
```


### notable HIV-1 strains
```{r}
# list of notable HIV-1 strains from subtypes B and C
notable_hiv1_isolates <- list(
  # Well-characterized laboratory-adapted viral isolates
  lab_adapted_isolates = list(
    strains = c("JRCSF", "JRFL", "YU2"),
    references = c(
      "JRCSF/JRFL" = "Das et al. (2016) demonstrated that JRCSF Env glycoprotein is efficiently cleaved on the cell surface and displays broadly neutralizing epitopes. Both JRCSF and JRFL were isolated from the same patient and are widely used clade B viral isolates in HIV-1 neutralization studies.",
      "YU2" = "A well-characterized primary HIV-1 isolate used extensively in neutralization assays and vaccine research, particularly for studying CD4 binding site interactions."
    )
  ),
  
  # Important subtype B viral isolates
  subtype_b_isolates = list(
    strains = c("92BR020", "92BR025_9"),
    references = c(
      "92BR020/92BR025_9" = "Brazilian viral isolates that have been incorporated into standard neutralization panels for subtype B HIV-1."
    )
  ),
  
  # Important Zambian clade C Env-pseudotyped viruses used in vaccine research
  zambian_env_pseudoviruses = list(
    strains = c("ZM247_V1", "ZM214_15", "ZM246F", "ZM249_1"),
    references = c(
      "ZM247_V1" = "Clade C Env-pseudotyped virus used in HIV vaccine research and included in standardized panels for neutralizing antibody assessments (Hraber et al., 2017).",
      "ZM strains" = "Env-pseudotyped viruses that form part of standardized HIV-1 subtype C reference panels for neutralization assessments representing diverse African viral sequences."
    )
  ),
  
  # Transmitted/founder (T/F) viral isolates important for research
  transmitted_founder_isolates = list(
    strains = c("CH505_TF", "TRJO4551_58", "REJO4541_67"),
    references = c(
      "CH505_TF" = "Transmitted/founder virus studied extensively in the context of HIV-1 antibody development and evolution; the env gene was used to create SHIV.CH505 for nonhuman primate models.",
      "TRJO4551_58/REJO4541_67" = "Important transmitted/founder viral isolates used in neutralization studies to characterize antibody responses."
    )
  ),
  
  # Viral isolates important for broadly neutralizing antibody research
  bnAb_characterization_isolates = list(
    strains = c("CAP256_SU"),
    # references = c(
    #   "CAP256_SU" = "Viral isolate extensively studied for broadly neutralizing antibody research targeting the V1/V2 epitopes."
    # )
    references = c(
      "CAP256_SU" = "Superinfecting viral isolate from donor CAP256 (from the Centre for the AIDS Programme of Research in South Africa) that was pivotal in eliciting the development of the potent V2-directed bNAb lineage CAP256-VRC26. This superinfecting virus and the potent antibodies it induced have been extensively characterized (Doria-Rose et al., 2014; Sacks et al., 2019; Moshoette et al., 2019)."
    )
  ),
  
  # Important recombinant viral forms
  recombinant_isolates = list(
    strains = c("BF1266_431A"),
    references = c(
      "BF1266_431A" = "Represents an important HIV-1 recombinant viral isolate used in genetic diversity studies."
    )
  )
)

citation_info <- c(
  "Doria-Rose, N. A., Schramm, C. A., Gorman, J., Moore, P. L., Bhiman, J. N., DeKosky, B. J., ... & Mascola, J. R. (2014). Developmental pathway for potent V1V2-directed HIV-neutralizing antibodies. Nature, 509(7498), 55-62.",
  "Sacks, D., Bhiman, J. N., Wiehe, K., Gorman, J., Kwong, P. D., Morris, L., & Moore, P. L. (2019). Somatic hypermutation to counter a globally rare viral immunotype drove off-track antibodies in the CAP256-VRC26 HIV-1 V2-directed bNAb lineage. PLoS Pathogens, 15(9), e1008005.",
  "Moshoette, T., Ali, S. A., Papathanasopoulos, M. A., & Killick, M. A. (2019). Engineering and characterising a novel, highly potent bispecific antibody iMab-CAP256 that targets HIV-1. Retrovirology, 16, 1-12."
  )

all_notable_strains <- unique(unlist(notable_hiv1_isolates))


```


```{r}
dim_config <- new_dim_reduction_config(
  method = "pca",
  n_components = 2,
  scale = FALSE
)

layout_config <- new_layout_config(
  width = 3.26772,
  height = 2.6,
  dpi = 300,
  x_limits = c(-3.1, 3.1),
  y_limits = c(-3, 4),
  plot_margin = margin(0.05, 0.05, 0.05, 0.05, "cm"),
  save_format = "pdf"
)

aesthetic_config <- new_aesthetic_config(
  point_shapes = c(antigen = 16, antiserum = 4),
  point_size = 1.5,
  point_alpha = 0.65,
  title_size = 7,
  subtitle_size = 6,
  axis_title_size = 6,
  axis_text_size = 6,
  legend_text_size =  6,
  legend_title_size = 6,
  show_legend = TRUE,
  legend_position = "right",
  show_title = FALSE
)

annotation_config <- new_annotation_config(
  notable_points = all_notable_strains,         # Points to annotate
  size = 4.9,                              # Text size
  color = "black",                         # Text color
  fontface = "bold",                       # Text style
  outline_size = 0.4                       # Size of point outlines
)


topolow_plot <- plot_cluster_mapping(
  positions_topolow,
  ndim = datasets$HIV$topolow_params$N,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config,
  show_shape_legend = FALSE,
  cluster_legend_title = "Subtype"
) 

racmacs_plot <- plot_cluster_mapping(
  positions_racmacs,
  ndim = datasets$HIV$racmacs_dim,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config,
  show_shape_legend = FALSE,
  cluster_legend_title = "Subtype"
) 

# annotated
topolow_plot <- plot_cluster_mapping(
  positions_topolow,
  ndim = datasets$HIV$topolow_params$N,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config,
  show_shape_legend = FALSE,
  annotation_config = annotation_config,
  cluster_legend_title = "Subtype"
)

# annotated
racmacs_plot <- plot_cluster_mapping(
 positions_racmacs,
  ndim = datasets$HIV$racmacs_dim,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config,
  layout_config = layout_config,
  show_shape_legend = FALSE,
 annotation_config = annotation_config,
  cluster_legend_title = "Subtype"
)
```

## Run Error Comparison

Create data collection tables

```{r}
# Initialize results storage
errors_df <- data.table(
  InSampleError = numeric(),
  OutSampleError = numeric(),
  InSamplePercentageError = numeric(),
  OutSamplePercentageError = numeric(),
  Dimension = numeric(),
  Algorithm = character(),
  Scenario = character(),
  Dataset = character(), 
  Fold = numeric(),
  stringsAsFactors = FALSE
)

Completeness_df <- data.table(
  Mapped = numeric(),
  Total = numeric(),
  Validation_Completeness = numeric(),
  Algorithm = character(),
  Dataset = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

```

Process each dataset through cross-validation:

```{r eval=FALSE}
# Process each dataset
for(dataset_name in names(datasets) ) { 
  # Get dataset and parameters
  distance_matrix <- datasets[[dataset_name]]$matrix
  topolow_params <- datasets[[dataset_name]]$topolow_params
  racmacs_dim <- datasets[[dataset_name]]$racmacs_dim
  # Create CV folds
  matrix_list <- create_cv_folds(
    truth_matrix = distance_matrix,
    n_folds = opt_setting$n_folds
  )
  
  # Run comparison for each fold
  for(i in seq_len(opt_setting$n_folds)) {
    # Get matrices for this fold
    truth_matrix <- matrix_list[[i]][[1]]
    input_matrix <- matrix_list[[i]][[2]]
    
    ################# Run Topolow
    
    res_train <- create_topolow_map(
      distance_matrix = input_matrix,
      ndim = topolow_params$N,
      mapping_max_iter = opt_setting$max_topolow_iter,
      k0 = topolow_params$k0,
      cooling_rate = topolow_params$cooling_rate,
      c_repulsion = topolow_params$c_repulsion,
      relative_epsilon = 1e-10,
      convergence_counter = 3,
      initial_positions = NULL,
      write_positions_to_csv = FALSE,
      verbose = FALSE
    )

    p_dist_mat <- res_train$est_distances

    # Calculate Topolow errors
    topo_errors <- error_calculator_comparison(
      p_dist_mat = p_dist_mat,
      truth_matrix = truth_matrix,
      input_matrix = input_matrix
    )

    # Store Topolow results
    topo_df <- topo_errors$report_df
    topo_df$Dimension = topolow_params$N
    topo_df$Algorithm = "Topolow"
    topo_df$Scenario = "Topolow"
    topo_df$Dataset <- dataset_name
    topo_df$Fold <- i

    errors_df <- rbind(errors_df, topo_df)

    Completeness_df <- rbind(
      Completeness_df,
      data.table(
        Mapped = nrow(p_dist_mat),
        Total = nrow(truth_matrix),
        Validation_Completeness = topo_errors$Completeness,
        Algorithm = "Topolow",
        Dataset = dataset_name,
        Fold = i
      )
    )

    
    ################# Run RACMACS
    
    # Convert to titer format
    if(dataset_name %in% c("H3N2", "DENV")) {
      titer_table <- dist_to_titer_table(input_matrix, base=2, tens=10)
    } else {
      titer_table <- dist_to_titer_table(input_matrix, tens=1)
    }
    
    map <- create_and_optimize_RACMACS_map(
      titer_table = titer_table,
      dim = racmacs_dim,
      optimization_number = opt_setting$racmacs_opt_rounds,
      num_cores = opt_setting$num_cores
    )
    
    # Save coordinates
    coords_file <- file.path(output_dir, 
                            paste0(dataset_name, "_RACMACS_coords_", i, ".csv"))
    save.coords(map, filename = coords_file,
               optimization_number = 1, antigens = TRUE, sera = TRUE)
    
    # Process RACMACS results
    positions_racmacs <- read.csv(coords_file)
    positions_racmacs$name <- ifelse(
      positions_racmacs$type == "antigen",
      paste0("V/", positions_racmacs$name),
      paste0("S/", positions_racmacs$name)
    )
    
    rownames(positions_racmacs) <- positions_racmacs$name
    positions_racmacs <- positions_racmacs[,3:ncol(positions_racmacs)]
    
    # Calculate RACMACS distances
    p_dist_mat <- coordinates_to_matrix(as.matrix(positions_racmacs))
    
    racmacs_errors <- error_calculator_comparison(
      p_dist_mat = p_dist_mat,
      truth_matrix = truth_matrix,
      input_matrix = input_matrix
    )
    
    # Store RACMACS results
    racmacs_df <- racmacs_errors$report_df
    racmacs_df$Dimension = racmacs_dim
    racmacs_df$Algorithm = "MDS"
    racmacs_df$Scenario = "MDS"
    racmacs_df$Dataset <- dataset_name
    racmacs_df$Fold <- i
    
    errors_df <- rbind(errors_df, racmacs_df)
    
    Completeness_df <- rbind(
      Completeness_df,
      data.table(
        Mapped = nrow(p_dist_mat),
        Total = nrow(truth_matrix),
        Validation_Completeness = racmacs_errors$Completeness,
        Algorithm = "MDS",
        Dataset = dataset_name,
        Fold = i
      )
    )
    
  }
}

write.csv(errors_df, file.path(output_dir, "errors_df_loop.csv"), row.names = FALSE)
write.csv(Completeness_df, file.path(output_dir, "Completeness_df_loop.csv"), row.names = FALSE )
```


## Statistical Analysis

```{r}
# Read the CSV files back into dataframes
errors_df <- read.csv(file.path(output_dir, "errors_df_loop.csv"))
Completeness_df <- read.csv(file.path(output_dir, "Completeness_df_loop.csv"))
```


Perform paired t-tests to compare algorithm performance:

```{r}
# Calculate fold-level statistics
fold_stats <- aggregate(
  OutSampleError ~ Dataset + Algorithm + Fold,
  data = errors_df,
  FUN = function(x) mean(abs(x), na.rm = TRUE)
)

# Perform paired t-tests for each dataset
stat_tests <- fold_stats %>%
  group_by(Dataset) %>%
  summarize(
    t_stat = t.test(OutSampleError[Algorithm == "MDS"],
                    OutSampleError[Algorithm == "Topolow"],
                    paired = TRUE)$statistic,
    p_value = t.test(OutSampleError[Algorithm == "MDS"],
                     OutSampleError[Algorithm == "Topolow"],
                     paired = TRUE)$p.value,
    .groups = 'drop'
  ) %>%
  mutate(
    Sig.Level = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**",
      p_value < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  )

print("Statistical Test Results:")
knitr::kable(stat_tests)
```

## Results Visualization
```{r}
## ---- Results Visualization --------------------------------------------------
# font sizes
base_size <- 8          # Base font size
axis_title_size <- 9    # Size for axis titles
axis_text_size <- 8     # Size for axis text
plot_title_size <- 9    # Size for plot title
legend_title_size <- 8   # Size for legend title
legend_text_size <- 8    # Size for legend text
stat_text_size <- 2.6      # Size for MAE/SD statistics

# Calculate summary statistics
error_summary <- errors_df %>%
  # Remove possible errors in the data using clean_data function with k=3.5 to remove points 3.5 SD away.
  group_by(Dataset, Algorithm) %>%
  mutate(
    OutSampleError = clean_data(OutSampleError, k = 3.5)
  ) %>%
  # Calculate summary statistics
  summarise(
    MAE = round(mean(abs(OutSampleError), na.rm = TRUE), 3),
    SD  = round(sd(abs(OutSampleError),  na.rm = TRUE), 3),
    .groups = 'drop'
  ) %>%
  mutate(
    label = sprintf("%.3f\n%.3f", MAE, SD)
  )

# ---------------------------------------------------------------------------
#   separate top- and bottom-padding so we have an “annotation band”
#   equal to 35 % of the core y-range
core_vals   <- clean_data(errors_df$OutSampleError, k = 3.05)
core_min    <- min(core_vals, na.rm = TRUE)
core_max    <- max(core_vals, na.rm = TRUE)
core_range  <- abs(core_max - core_min)

pad_top     <- core_range * 0.05          # keeps your original 22 % head-room
pad_bottom  <- core_range * 0.36          # NEW: reserve 35 % for MAE / SD

# Calculate the y-position for the labels (center of the annotation band)
label_y_pos <- core_min - pad_bottom / 2 - 0.45

p1 <- ggplot() +
  # Add box plots with outliers removed
  geom_boxplot(
    data = errors_df,
    aes(x = Dataset, y = OutSampleError,
        fill = Algorithm),
    position = position_dodge(width = 0.8),
    outlier.shape = NA,  # Remove outliers
    alpha = 0.8
  ) +
  # Add text labels for MAE and SD
  geom_text(
    data = error_summary,
    aes(x = Dataset, y = label_y_pos,
        label = label, group = Algorithm),
    position = position_dodge(width = 0.8),
    vjust = 1,
    size  = stat_text_size,
    color = "black"
  ) +
  # Add MAE/SD label on the left side
  annotate(
    "text",
    x = 0.56,  # Left edge of the plot area
    y = label_y_pos,
    label = "MAE=\nSD=",
    size  = stat_text_size,
    vjust = 1,
    color = "black"
  ) +
  # Customize appearance
  scale_fill_manual(values = c("Topolow" = "#4dbedf", "MDS" = "#e59572")) +
  scale_y_continuous(
    limits = c(core_min - pad_bottom, core_max + pad_top / 20),
    expand = c(0, 0)
  ) +
  # Allow drawing outside the plot area
  #coord_cartesian(clip = "off") +
  theme_minimal(base_size = base_size) +
  theme(
    # Increase left margin to make room for the label
    #plot.margin = margin(5, 5, 5, 40, "pt"),
    axis.title = element_text(size = axis_title_size),
    axis.text  = element_text(size = axis_text_size),
    axis.text.x = element_text(hjust = 1),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border     = element_rect(color = "black", fill = NA, linewidth = 0.5),
    legend.position  = c(0.5, 0.95),
    legend.direction = "horizontal",
    legend.background = element_rect(fill = "white", color = NA),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.margin     = margin(0.05, 0.7, 0.0, 0.7),
    legend.key.size   = unit(0.8, "lines"),
    legend.title      = element_text(size = legend_title_size),
    legend.text       = element_text(size = legend_text_size),
    legend.box.margin = margin(0, 0, 0, 0)
  ) +
  labs(
    x = NULL,
    y = "Error (validation data)",
    fill = "Algorithm"
  )

ggsave_white_bg(
  file.path(plots_dir, "comparison_real_data.pdf"),
  p1,
  width  = 100,
  height = 80,          # keep your original height
  units  = "mm"
)

```


```{r}

# Print summary table
knitr::kable(
  error_summary %>% 
    select(Dataset, Algorithm, MAE, SD),
  caption = "Error Summary Statistics"
)
```

```{r}
# Calculate fold-level statistics
fold_stats <- aggregate(
  OutSampleError ~ Dataset + Algorithm + Fold,
  data = errors_df,
  FUN = function(x) mean(abs(x), na.rm = TRUE)
)

# Calculate summary statistics
summary_stats <- fold_stats %>%
  group_by(Dataset, Algorithm) %>%
  summarize(
    Mean = mean(OutSampleError),
    SD = sd(OutSampleError),
    .groups = 'drop'
)

# Calculate dataset statistics
data_stats <- list(
  HIV = summary(as.numeric(hiv_matrix), na.rm=TRUE),
  H3N2 = summary(as.numeric(h3n2_matrix), na.rm=TRUE),
  DENV = summary(as.numeric(denv_distance_matrix), na.rm=TRUE)
)

# Add mean distance to summary_stats
summary_stats$MeanDist <- sapply(summary_stats$Dataset, 
                                function(d) mean(as.numeric(datasets[[d]]$matrix), na.rm=TRUE))
summary_stats$RelativeMAE <- summary_stats$Mean / summary_stats$MeanDist * 100
```

Create comparison plots:

```{r}
# Calculate fold-level statistics
fold_stats <- aggregate(
  OutSampleError ~ Dataset + Algorithm + Fold,
  data = errors_df,
  FUN = function(x) mean(abs(x), na.rm = TRUE)
)

# Calculate summary statistics
summary_stats <- fold_stats %>%
  group_by(Dataset, Algorithm) %>%
  summarize(
    Mean = mean(OutSampleError),
    SD = sd(OutSampleError),
    .groups = 'drop'
  )

# Calculate quantile-based statistics for each dataset
data_ranges <- list(
  HIV = quantile(as.numeric(hiv_matrix), 
                 probs = c(0.05, 0.25, 0.5, 0.75, 0.95), 
                 na.rm = TRUE),
  H3N2 = quantile(as.numeric(h3n2_matrix), 
                  probs = c(0.05, 0.25, 0.5, 0.75, 0.95), 
                  na.rm = TRUE),
  DENV = quantile(as.numeric(denv_distance_matrix), 
                  probs = c(0.05, 0.25, 0.5, 0.75, 0.95), 
                  na.rm = TRUE)
)

# Create data frame for range lines
range_data <- data.frame(
  Dataset = names(data_ranges),
  ymin = sapply(data_ranges, function(x) x["5%"]),
  ymax = sapply(data_ranges, function(x) x["95%"])
)

# Create the plot
p1 <- ggplot() +
  # Add MAE bars
  geom_bar(data = summary_stats,
           aes(x = Dataset, y = Mean, fill = Algorithm),
           stat = "identity", position = position_dodge()) +
  geom_errorbar(data = summary_stats,
                aes(x = Dataset, y = Mean, 
                    ymin = Mean - SD, ymax = Mean + SD,
                    group = Algorithm),
                position = position_dodge(width = 0.9),
                width = 0.25) +
  scale_fill_manual(values = c("Topolow" = "#3366CC", "MDS" = "#DC3912")) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    legend.position = "top"
  ) +
  labs(
    title = "Out-of-Sample Mean Absolute Error",
    subtitle = paste(
      "Data Ranges (5th-95th percentiles):",
      sprintf("\nHIV: (%.2f - %.2f)", range_data$ymin[[1]], range_data$ymax[[1]]),
      sprintf("\nH3N2: (%.2f - %.2f)", range_data$ymin[[2]], range_data$ymax[[2]])
    ),
    y = "MAE (±SD)"
  )

print(p1)

# Print context statistics
for(dataset in names(data_ranges)) {
  cat("\n", dataset, "statistics:\n")
  print(data_ranges[[dataset]])
  cat("MAE values:\n")
  print(summary_stats[summary_stats$Dataset == dataset,])
}
```



## Summary Tables

Create detailed performance summary tables:

```{r}
# Error summary table
error_summary <- summary_stats %>%
  mutate(
    Performance = sprintf("%.3f ± %.3f", Mean, SD)
  ) %>%
  select(Dataset, Algorithm, Performance) %>%
  tidyr::pivot_wider(names_from = Algorithm,
                     values_from = Performance)

print("Mean Absolute Error Summary:")
knitr::kable(error_summary)


# Completeness summary
Completeness_summary <- Completeness_df %>%
  group_by(Dataset, Algorithm) %>%
  summarize(
    Mean_Completeness = mean(Validation_Completeness),
    SD_Completeness = sd(Validation_Completeness),
    .groups = 'drop'
  ) %>%
  mutate(
    Completeness = sprintf("%.1f%% ± %.1f%%", 
                      Mean_Completeness * 100, 
                      SD_Completeness * 100)
  ) %>%
  select(Dataset, Algorithm, Completeness) %>%
  tidyr::pivot_wider(names_from = Algorithm,
                     values_from = Completeness)

print("\nCompleteness Summary:")
knitr::kable(Completeness_summary)
```

## Distribution of Errors

Examine the distribution of errors for both algorithms:

```{r}
# Calculate error distributions
error_dist <- errors_df %>%
  group_by(Dataset, Algorithm) %>%
  summarize(
    Mean = mean(OutSampleError, na.rm = TRUE),
    SD = sd(OutSampleError, na.rm = TRUE),
    Median = median(OutSampleError, na.rm = TRUE),
    Q1 = quantile(OutSampleError, 0.25, na.rm = TRUE),
    Q3 = quantile(OutSampleError, 0.75, na.rm = TRUE),
    .groups = 'drop'
  )

print("Error Distribution Summary:")
knitr::kable(error_dist)
```

## Session Info

```{r}
sessionInfo()
```
```
