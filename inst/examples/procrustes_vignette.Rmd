---
title: "Assessing Antigenic Map Stability with Procrustes Analysis"
author: "Omid Arhami"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Assessing Antigenic Map Stability with Procrustes Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 6,
  warning = TRUE,
 message = TRUE,    # Show messages
  error = TRUE      # Continue on error
)
```

## Introduction

This vignette demonstrates how to assess the run-to-run stability of antigenic maps using Procrustes analysis. We compare the stability of maps generated by both TopoLow and MDS (RACMACS) algorithms across multiple independent optimization runs. The analysis is performed on two real datasets:

1. H3N2 influenza HI assay data from Smith et al. 2004 
2. HIV neutralization data from Los Alamos HIV database

## Required Packages

```{r}
library(topolow)
library(Racmacs)
library(vegan)     # For Procrustes analysis
library(dplyr)
library(ggplot2)
library(gridExtra)

# Setup output directory
output_dir <- "procrustes_results"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}
```

## Methods

### Procrustes Analysis Details

Procrustes analysis quantifies shape difference between point configurations by:

1. Finding optimal rotation, translation and scaling to minimize differences
2. Calculating sum of squared distances between corresponding points
3. Testing significance through permutations 

Lower Procrustes distances indicate more consistent point configurations across optimization runs.
## Load and Process Data

Load and prepare both datasets:

```{r}
# Load and process HIV data

# Combine the two files downloaded from Los Alamos website:
data("hiv_titers")

data("hiv_viruses")

# Add meta data
hiv_viruses <- hiv_viruses %>%
  dplyr::select(c("Virus.name", "Country", "Subtype", "Year"))

hiv_titers <- hiv_titers %>% 
  dplyr::left_join(hiv_viruses, by = join_by(Virus == Virus.name)) %>%
  dplyr::select(c("Antibody", "Virus", "Country", "Subtype", "Year", "IC50")) %>% 
  dplyr::rename("virusYear" = "Year")

hiv_titers <- na.omit(hiv_titers)

hiv_titers <- hiv_titers %>% dplyr::filter(IC50 != "")

hiv_titers <- hiv_titers %>% dplyr::filter(Subtype %in% c("B", "C")) #, "01_AE", "A1", "G", "07_BC", "02_AG", "D", "A1D", "02A1"

hiv_titers$IC50 <- clean_data(hiv_titers$IC50, k=2, take_log=TRUE)
hiv_titers <- na.omit(hiv_titers)

# Sort the dataset based on the "year" column
hiv_titers <- hiv_titers[order(hiv_titers$virusYear), ]

# Save the merged and prepared raw data into a csv:
write.csv(hiv_titers, file.path(output_dir,"hiv_assay_full.csv"))

# Load and process HIV data
hiv_results <- process_antigenic_data(
  file_path = "procrustes_results/hiv_assay_full.csv",
  antigen_col = "Virus",
  serum_col = "Antibody", 
  value_col = "IC50",
  is_titer = FALSE,
  base = 2,
  scale_factor = 1,
  metadata_cols = c("Subtype", "Country")
)

# Extract distance matrix
hiv_distance_matrix <- hiv_results$matrix
hiv_long <- hiv_results$long


# Create filtered dataset
create_filtered_dataset <- function(data, optimal_cutoff, insufficient_thresh) {
  # Find top viruses
  top_viruses <- data %>%
    group_by(virusYear, Virus) %>%
    summarise(n_sera = n_distinct(Antibody), .groups = 'drop') %>%
    group_by(virusYear) %>%
    filter(n_sera > insufficient_thresh) %>%
    slice_max(order_by = n_sera, n = optimal_cutoff)
  
  # Find top sera
  top_sera <- data %>%
    group_by(virusYear, Antibody) %>%
    summarise(n_virus = n_distinct(Virus), .groups = 'drop') %>%
    group_by(virusYear) %>%
    filter(n_virus > insufficient_thresh) %>%
    slice_max(order_by = n_virus, n = optimal_cutoff)
  
  # Create filtered dataset
  filtered_data <- data %>%
    semi_join(top_viruses, by = c("virusYear", "Virus")) %>%
    semi_join(top_sera, by = c("virusYear", "Antibody"))
  
  return(filtered_data)
}

# Create filtered dataset with optimal cutoff=8
insufficient_thresh = 5
optimal_cutoff = 11
filtered_data <- create_filtered_dataset(hiv_long, optimal_cutoff, insufficient_thresh)

# Remove pairs with insufficient measurements (< 3 unique partners)
# Count unique partners for each Antibody and Virus
pairing_counts <- list(
  antibodies = filtered_data %>%
    group_by(Antibody) %>%
    summarise(n_partners = n_distinct(Virus)) %>%
    filter(n_partners >= 3),
  
  viruses = filtered_data %>%
    group_by(Virus) %>%
    summarise(n_partners = n_distinct(Antibody)) %>%
    filter(n_partners >= 3)
)

# Filter data to keep only entries with sufficient partners
filtered_data <- filtered_data %>%
  filter(Antibody %in% pairing_counts$antibodies$Antibody,
         Virus %in% pairing_counts$viruses$Virus)

write.csv(filtered_data, file.path(output_dir,"hiv_filtered_long_data.csv"))


hiv_matrix <- long_to_matrix(filtered_data,
                            chnames = "Virus",
                            rnames = "Antibody", 
                            values_column = "distance",
                            rc = FALSE,
                            sort = TRUE)
```

```{r}
# Load and process H3N2 data of Smith et al 2004
data(h3n2_data)

write.csv(h3n2_data, file.path(output_dir,"h3n2_data.csv"), row.names = FALSE)

h3n2_results <- process_antigenic_data(
  file_path = "procrustes_results/h3n2_data.csv",
  antigen_col = "virusStrain",
  serum_col = "serumStrain",
  value_col = "titer", 
  is_titer = TRUE,
  metadata_cols = c("virusYear", "serumYear", "cluster", "color")
)

h3n2_matrix <- h3n2_results$matrix
```

```{r}
# Load and process Denv data of Katzelnick et al 2015 (also in Bell et al 2019)
denv_data_results <- process_antigenic_data(
  file_path = "data_files/DENV_titers.csv",
  antigen_col = "virus_strain",
  serum_col = "serum_strain",
  value_col = "titer", 
  is_titer = TRUE,
  metadata_cols = c("virusYear", "serumYear", "cluster", "color")
)

# Extract distance matrix
denv_matrix <- denv_data_results$matrix
```

## Run Multiple Optimizations

For each dataset and method, we generate 15 independent maps to assess stability:

```{r}
# Function to identify common valid points across all maps
get_valid_points <- function(maps) {
  # Get points that have no NAs in any map
  valid_points <- Reduce(intersect, 
    lapply(maps, function(map) {
      rownames(map)[complete.cases(map)]
    })
  )
  return(valid_points)
}

# Function to run multiple TopoLow optimizations
generate_topolow_maps <- function(distance_matrix, params, valid_points, n_maps = 15) {
  maps <- vector("list", n_maps)
  
  for(i in 1:n_maps) {
    res <- create_topolow_map(
      distance_matrix = distance_matrix,
      ndim = params$N, 
      mapping_max_iter = 100,
      k0 = params$k0,
      cooling_rate = params$cooling_rate,
      c_repulsion = params$c_repulsion,
      relative_epsilon = 1e-10,
      convergence_counter = 2,
      write_positions_to_csv = FALSE
    )
    
    # Extract and project coordinates if needed
    positions <- as.data.frame(res$positions)
    if(ncol(positions) > 2) {
      # Project to 2D using PCA
      pca <- prcomp(positions, scale. = TRUE)
      positions <- data.frame(
        X = pca$x[,1], 
        X.1 = pca$x[,2]
      )
    }
    # Filter for valid points only
    positions <- positions[valid_points, ]
    maps[[i]] <- positions
  }
  
  return(maps)
}

# Function to run multiple RACMACS optimizations
generate_racmacs_maps <- function(distance_matrix, dataset_name, n_maps = 15) {
  maps <- vector("list", n_maps)
  
  # Convert to titer table
  if(dataset_name == "H3N2") {
    titer_table <- dist_to_titer_table(distance_matrix, base=2, tens=10)
  } else {
    titer_table <- dist_to_titer_table(distance_matrix, tens=1)
  }

  for(i in 1:n_maps) {
    map <- create_and_optimize_RACMACS_map(
      titer_table = titer_table,
      optimization_number = 500,
      num_cores = 6
    )
    # Save coordinates
    save.coords(map, filename = "Procrustes_RACMACS_coords.csv",
               optimization_number = 1, antigens = TRUE, sera = TRUE)
    
    # Process RACMACS results
    positions_racmacs <- read.csv("Procrustes_RACMACS_coords.csv")
    positions_racmacs$name <- ifelse(
      positions_racmacs$type == "antigen",
      paste0("V/", positions_racmacs$name),
      paste0("S/", positions_racmacs$name)
    )
    
    rownames(positions_racmacs) <- positions_racmacs$name
    positions_racmacs <- positions_racmacs[,3:ncol(positions_racmacs)]
    
    maps[[i]] <- positions_racmacs
  }
  
  return(maps)
}

# Load optimal parameters for each dataset
# HIV parameter chains
hiv_chains <- c(
  "model_parameters/HIV_BC_AMC202_model_parameters.csv",
  "model_parameters/HIV_BC_AMC203_model_parameters.csv",
  "model_parameters/HIV_BC_AMC204_model_parameters.csv",
  "model_parameters/HIV_BC_AMC205_model_parameters.csv",
  "model_parameters/HIV_BC_AMC206_model_parameters.csv"
)

# H3N2 parameter chains  
h3n2_chains <- c(
  "model_parameters/H3N2_2003_data_AMC201_model_parameters.csv",
  "model_parameters/H3N2_2003_data_AMC202_model_parameters.csv",
  "model_parameters/H3N2_2003_data_AMC203_model_parameters.csv",
  "model_parameters/H3N2_2003_data_AMC205_model_parameters.csv"
)

denv_chains <- c(
  "model_parameters/denv_data_AMC101_model_parameters.csv",
  "model_parameters/denv_data_AMC102_model_parameters.csv",
  "model_parameters/denv_data_AMC103_model_parameters.csv",
  "model_parameters/denv_data_AMC104_model_parameters.csv",
  "model_parameters/denv_data_AMC105_model_parameters.csv"
)

# Function to read and clean one CSV
clean_and_overwrite <- function(file_path) {
  # 1. Read every column in as character
  df <- read.csv(file_path, stringsAsFactors = FALSE, colClasses = "character")
  
  # 2. For each column: remove any literal doubleâ€quotes and coerce to numeric
  df[] <- lapply(df, function(col) {
    # strip all " characters (in case they were embedded in the field)
    col_stripped <- gsub('"', "", col, fixed = TRUE)
    # convert the result to numeric
    as.numeric(col_stripped)
  })
  
  # 3. Write back to the same path, preserving only the data
  write.csv(df, file = file_path, row.names = FALSE)
}

# 4. Apply to every file
invisible(lapply(hiv_chains, clean_and_overwrite))
invisible(lapply(h3n2_chains, clean_and_overwrite))
invisible(lapply(denv_chains, clean_and_overwrite))


# Function to get optimal parameters from chains
get_optimal_params <- function(chain_files) {
  # Read and combine chains
  chains <- do.call(rbind, lapply(chain_files, read.csv))
  
  # Clean and filter
  chains <- chains %>%
    filter(!is.na(NLL) & !is.na(Holdout_MAE) & 
             is.finite(NLL) & is.finite(Holdout_MAE)) %>%
    na.omit()
  
  chains <- chains[chains$log_N >= log(2) & chains$log_N <= log(5),]
  # Apply clean_data to all columns of the dataframe
  chains <- as.data.frame(lapply(chains, clean_data, k = 3.5))
  chains <- na.omit(chains)

  # Get best parameters
  best_params <- chains[which.min(chains$Holdout_MAE),]

  list(
    N = round(exp(as.numeric(best_params$log_N))),
    k0 = exp(as.numeric(best_params$log_k0)),
    cooling_rate = exp(as.numeric(best_params$log_cooling_rate)),
    c_repulsion = exp(as.numeric(best_params$log_c_repulsion))
  )
}

# Get optimal parameters for each dataset
hiv_params <- get_optimal_params(hiv_chains)
h3n2_params <- get_optimal_params(h3n2_chains)
denv_params <- get_optimal_params(denv_chains)

print("HIV optimal parameters:")
print(hiv_params)
print("\nH3N2 optimal parameters:")
print(h3n2_params)
print("DENV optimal parameters:")
print(denv_params)
# Generate maps

# 1. Generate initial RACMACS maps to remove the points it fails to locate for both methods
h3n2_mds_maps_initial <- generate_racmacs_maps(h3n2_matrix, dataset_name = "H3N2", n_maps = 15)
hiv_mds_maps_initial <- generate_racmacs_maps(hiv_matrix, dataset_name = "HIV", n_maps = 15)
denv_mds_maps_initial <- generate_racmacs_maps(denv_matrix, dataset_name = "DENV", n_maps = 15)

# 2. Find valid points
h3n2_filtered_points <- get_valid_points(h3n2_mds_maps_initial)
hiv_filtered_points <- get_valid_points(hiv_mds_maps_initial)
denv_filtered_points <- get_valid_points(denv_mds_maps_initial)

# 3. Generate filtered maps for both methods
h3n2_mds_maps <- lapply(h3n2_mds_maps_initial, function(map) {
  map[h3n2_filtered_points, ]
})

hiv_mds_maps <- lapply(hiv_mds_maps_initial, function(map) {
  map[hiv_filtered_points, ]
})

denv_mds_maps <- lapply(denv_mds_maps_initial, function(map) {
  map[denv_filtered_points, ]
})

h3n2_topolow_maps <- generate_topolow_maps(h3n2_matrix, h3n2_params, h3n2_filtered_points, n_maps = 15)
hiv_topolow_maps <- generate_topolow_maps(hiv_matrix, hiv_params, hiv_filtered_points, n_maps = 15) 
denv_topolow_maps <- generate_topolow_maps(denv_matrix, denv_params, denv_filtered_points, n_maps = 15) 

# Add check of point counts
cat("H3N2 valid points:", length(h3n2_filtered_points), 
    "out of", nrow(h3n2_matrix), "\n")
cat("HIV valid points:", length(hiv_filtered_points),
    "out of", nrow(hiv_matrix), "\n")
cat("DENV valid points:", length(denv_filtered_points),
    "out of", nrow(denv_matrix), "\n")
```

## Calculate Stability Metrics

Now we'll calculate pairwise Procrustes distances between all maps for each method:

```{r}
# Function to calculate pairwise Procrustes distances
calc_procrustes_dists <- function(maps) {
  n <- length(maps)
  dists <- matrix(NA, n, n)
  
  for(i in 1:(n-1)) {
    for(j in (i+1):n) {
      proc <- procrustes(maps[[i]], maps[[j]])
      dists[i,j] <- dists[j,i] <- proc$ss
    }
  }
  
  return(dists)
}

# Calculate distances
h3n2_topo_dists <- calc_procrustes_dists(h3n2_topolow_maps)
h3n2_mds_dists <- calc_procrustes_dists(h3n2_mds_maps)
hiv_topo_dists <- calc_procrustes_dists(hiv_topolow_maps)
hiv_mds_dists <- calc_procrustes_dists(hiv_mds_maps)
denv_topo_dists <- calc_procrustes_dists(denv_topolow_maps)
denv_mds_dists <- calc_procrustes_dists(denv_mds_maps)

# Compile results
results_df <- data.frame(
  Dataset = rep(c("H3N2", "H3N2", "HIV", "HIV", "DENV", "DENV"), each = 1),
  Method = rep(c("TopoLow", "MDS"), 3),
  Dimension = c(2, 2, 2, 2, 2, 2),
  Mean = c(
    mean(h3n2_topo_dists[upper.tri(h3n2_topo_dists)]),
    mean(h3n2_mds_dists[upper.tri(h3n2_mds_dists)]),
    mean(hiv_topo_dists[upper.tri(hiv_topo_dists)]),
    mean(hiv_mds_dists[upper.tri(hiv_mds_dists)]),
    mean(denv_topo_dists[upper.tri(denv_topo_dists)]),
    mean(denv_mds_dists[upper.tri(denv_mds_dists)])
  ),
  SD = c(
    sd(h3n2_topo_dists[upper.tri(h3n2_topo_dists)]),
    sd(h3n2_mds_dists[upper.tri(h3n2_mds_dists)]), 
    sd(hiv_topo_dists[upper.tri(hiv_topo_dists)]),
    sd(hiv_mds_dists[upper.tri(hiv_mds_dists)]),
    sd(denv_topo_dists[upper.tri(denv_topo_dists)]),
    sd(denv_mds_dists[upper.tri(denv_mds_dists)])
  )
)

# Format and display results table
knitr::kable(
  results_df,
  caption = "Run-to-run stability analysis (Procrustes sum of squares)",
  digits = 2,
  align = c('l', 'l', 'r', 'r', 'r'),
  col.names = c("Data", "Method", "Map dimension", 
                "Mean sum of squared differences", 
                "Standard deviation")
)
```

## Statistical Analysis

We'll perform t-tests to compare the stability of methods for each dataset:

```{r}
# Function to run t-test on Procrustes distances
compare_stability <- function(dist_mat1, dist_mat2) {
  # Extract upper triangular distances
  dists1 <- dist_mat1[upper.tri(dist_mat1)]
  dists2 <- dist_mat2[upper.tri(dist_mat2)]
  
  # Perform t-test
  test <- t.test(dists1, dists2)
  
  data.frame(
    t_stat = test$statistic,
    p_value = test$p.value,
    sig_level = case_when(
      test$p.value < 0.001 ~ "***",
      test$p.value < 0.01 ~ "**",
      test$p.value < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  )
}

# Run tests
h3n2_test <- compare_stability(h3n2_topo_dists, h3n2_mds_dists)
hiv_test <- compare_stability(hiv_topo_dists, hiv_mds_dists)
denv_test <- compare_stability(denv_topo_dists, denv_mds_dists)

# Create results table  
test_results <- data.frame(
  Dataset = c("H3N2", "HIV", "DENV"),
  t_statistic = c(h3n2_test$t_stat, hiv_test$t_stat, denv_test$t_stat),
  p_value = c(h3n2_test$p_value, hiv_test$p_value, denv_test$p_value),
  significance = c(h3n2_test$sig_level, hiv_test$sig_level, denv_test$sig_level)
)

knitr::kable(
  test_results,
  caption = "Statistical comparison of method stability",
  digits = c(0, 2, 4, 0)
)
```

## Visualization

Let's visualize the distribution of Procrustes distances:

```{r}
# Prepare data for plotting
plot_data <- rbind(
  data.frame(
    Dataset = "H3N2",
    Method = "TopoLow", 
    Distance = h3n2_topo_dists[upper.tri(h3n2_topo_dists)]
  ),
  data.frame(
    Dataset = "H3N2", 
    Method = "MDS",
    Distance = h3n2_mds_dists[upper.tri(h3n2_mds_dists)]
  ),
  data.frame(
    Dataset = "HIV",
    Method = "TopoLow",
    Distance = hiv_topo_dists[upper.tri(hiv_topo_dists)]
  ),
  data.frame(
    Dataset = "HIV",
    Method = "MDS", 
    Distance = hiv_mds_dists[upper.tri(hiv_mds_dists)]
  )
)

# Create plot
ggplot(plot_data, aes(x = Method, y = Distance, fill = Method)) +
  geom_boxplot() +
  facet_wrap(~Dataset, scales = "free") +
  scale_fill_manual(values = c("TopoLow" = "#3366CC", "MDS" = "#DC3912")) +
  theme_minimal() +
  labs(
    title = "Distribution of Procrustes Distances Between Independent Runs",
    y = "Procrustes Sum of Squares"
  )
```

## Results Summary

The analysis reveals several key findings:

1. Both datasets show significantly lower Procrustes distances (p < 0.001) for TopoLow compared to MDS, indicating more consistent optimization results.

2. For the H3N2 dataset:
   - TopoLow shows mean Procrustes distance of 10.77 (SD = 4.94)
   - MDS shows mean Procrustes distance of 3970.43 (SD = 1034.61)

3. For the HIV dataset:
   - TopoLow shows mean Procrustes distance of 85.72 (SD = 26.25)
   - MDS shows mean Procrustes distance of 12628.26 (SD = 6601.05)

The lower Procrustes distances and smaller standard deviations for TopoLow suggest more reliable optimization that consistently converges to similar solutions across multiple runs.

## References

1. Gower, J.C. (1975) "Generalized procrustes analysis" Psychometrika, 40, 33-51.


```{r}
sessionInfo()
```
