---
title: "Comparing Topolow with RACMACS on simulated data"
author: "Omid Arhami"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Comparing Topolow with RACMACS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 6,
  warning = TRUE,
 message = TRUE,    # Show messages
  error = TRUE      # Continue on error
)
```

##Introduction

This vignette demonstrates how to perform a rigorous comparison between Topolow and RACMACS algorithms for antigenic cartography. We conduct k-fold cross-validation and evaluate performance using multiple metrics including mean absolute error (MAE), Mean Absolute Percentage Error (MAPE), and Completeness.

You need the optimal parameters to create topolow maps. They are in csv files named "optimal_parameters_250points.csv" which are provided on Github or you can generate them by running sufficient Monte Carlo simulations (on a distributed cluster or a machine with tens of CPU cores for faster calculations) in file synthetic-parameter-fitting.Rmd in the same folder as current file.

##Setup

First, we'll load required packages and set parameters:

```{r}
library(topolow)
library(Racmacs)
library(data.table)
library(dplyr)
library(parallel)
library(ggplot2)
library(tidyr)
library(gridExtra)
library(cowplot)

# Parameters

# Setup optimization parameters
opt_params <- list(
  n_folds = 20,
  max_topolow_iter = 1000, # Cutoff of one optimization
  topolow_opt_rounds = 1, # Optimization rounds for Topolow
  racmacs_opt_rounds = 100,  # Optimization rounds for RACMACS (You needs to do many optimizations and pick the best result)
  topolow_params = read.csv("optimal_parameters_250points.csv"),  # From parameter fitting
  use_slurm = FALSE,
  num_cores = 83
)

#  optimal dimensions of RACMACS
RACMACS_optimal_dims <- c(
  # 2D original dimension
  2, 2, 2,  # 70% (Missing, Noise, Noise+Bias)
  2, 2, 2,  # 85% (Missing, Noise, Noise+Bias)
  2, 2, 2,  # 95% (Missing, Noise, Noise+Bias)
  
  # 5D original dimension
  4, 4, 2,  # 70% (Missing, Noise, Noise+Bias)
  4, 4, 4,  # 85% (Missing, Noise, Noise+Bias)
  2, 2, 2,  # 95% (Missing, Noise, Noise+Bias)
  
  # 10D original dimension
  4, 4, 4,  # 70% (Missing, Noise, Noise+Bias)
  4, 4, 4,  # 85% (Missing, Noise, Noise+Bias)
  3, 3, 3   # 95% (Missing, Noise, Noise+Bias)
)
# Get absolute path for output directory
output_dir <- NULL
if (is.null(output_dir)) {
  output_dir <- file.path(getwd(), "synthetic_data")
}
output_dir <- normalizePath(output_dir, mustWork = FALSE)

# Create output directory if needed
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

# Create subdirectories
matrix_dir <- file.path(output_dir, "matrices")
topolow_results_dir <- file.path(output_dir, "topolow_results")
for (dir in c(matrix_dir, topolow_results_dir)) {
  if (!dir.exists(dir)) {
    dir.create(dir, recursive = TRUE)
  }
}
```

##Prepare Data and Cross-validation Folds

First, let's create synthetic datasets with different dimensionalities. We'll use synthetic distance matrices with different noise levels and missingness levels.

```{r}
# Generate datasets in 2, 5, and 10 dimensions
sim_data <- generate_synthetic_datasets(
  n_dims_list = c(2, 5, 10), 
  seeds = c(123450, 903450 , 13450), 
  n_points = 250,
  output_dir = "synthetic_data"
)

# Print dataset properties
print(sim_data$metadata)

# Get matrix variants to analyze
matrix_variants <- c("S_missing", "M_missing", "L_missing", "S_noise1", "M_noise1", "L_noise1", "S_noise_bias", "M_noise_bias", "L_noise_bias")
print("Matrix variants to analyze:")
print(matrix_variants)
```


## Find mds optimal dimensions (semi-manual)
```{r}
# Find Optimal Dimensionality for RACMACS MDS with Early Stopping
# S
# Analyzes each simulated dataset with increasing dimensionality until Completeness
# falls below 95% or max dimension is reached.
#
# @param sim_data The sim_data from generate_synthetic_datasets 
# @param matrix_variants Vector of matrix variant names to test
# @param opt_setting List of optimization settings
# @param output_dir Directory of the outputs
# @return Data table with dimension results across all variants
find_optimal_racmacs_dimensions <- function(sim_data, matrix_variants, opt_setting, output_dir) {
  # Initialize results storage
  dim_results <- data.table(
    Dimension = integer(),
    MAE = numeric(),
    MAPE = numeric(),
    Completeness = numeric(),
    OriginalDimension = integer(),
    Variant = character(),
    Algorithm = character(),
    stringsAsFactors = FALSE
  )
  
  # Create output directories if they don't exist
  racmacs_coords_dir <- file.path(output_dir, "racmacs_coordinates")  
  plots_dir <- file.path(output_dir, "plots")
  for (dir in c(racmacs_coords_dir, plots_dir)) {
    if (!dir.exists(dir)) {
      dir.create(dir, recursive = TRUE)
    }
  }
  
  # Maximum dimension to test before forcing early stop
  max_test_dimension <- 8
  
  # Process each original dataset dimension
  for(dim_idx in seq_along(sim_data$metadata$dimension)) {
    orig_dim <- sim_data$metadata$dimension[dim_idx]
    cat(sprintf("\nProcessing original %dD dataset\n", orig_dim))
    
    # Process each matrix variant
    for(variant in matrix_variants) {
      cat(sprintf("  Analyzing variant: %s\n", variant))
      
      # Get the distance matrix for this dimension and variant
      distance_matrix <- sim_data$matrices[[dim_idx]][[variant]]
      
      # Create CV folds
      matrix_list <- create_cv_folds(
        truth_matrix = distance_matrix,
        n_folds = opt_setting$n_folds
      )
      
      # Test dimensions starting from 2, incrementing until Completeness < 95%
      continue_testing <- TRUE
      test_dim <- 2  # Start with 2D
      
      while(continue_testing && test_dim <= max_test_dimension) {
        cat(sprintf("    Testing dimension %d\n", test_dim))
        
        # Storage for this dimension's folds
        fold_mae <- numeric(opt_setting$n_folds)
        fold_mape <- numeric(opt_setting$n_folds)
        fold_Completeness <- numeric(opt_setting$n_folds)
        
        # Run each fold
        for(i in seq_len(opt_setting$n_folds)) {
          # Get matrices for this fold
          truth_matrix <- matrix_list[[i]][[1]]
          input_matrix <- matrix_list[[i]][[2]]
          
          # Convert to titer format
          titer_table <- dist_to_titer_table(input_matrix, base=exp(1), tens=1)
          
          # Create scenario name for this run
          scenario_name <- sprintf("dim%d_%s_fold%d", orig_dim, variant, i)
          
          # Run RACMACS optimization
          map <- create_and_optimize_RACMACS_map(
            titer_table = titer_table,
            dim = test_dim,
            optimization_number = opt_setting$racmacs_opt_rounds,
            num_cores = opt_params$num_cores,
            scenario_name = scenario_name
          )
          
          # Save coordinates
          coords_file <- file.path(racmacs_coords_dir, 
                                  paste0("RACMACS_", scenario_name, ".csv"))
          save.coords(map, filename = coords_file,
                     optimization_number = 1, antigens = TRUE, sera = TRUE)
          
          # Process RACMACS results
          positions_racmacs <- read.csv(coords_file)
          positions_racmacs$name <- ifelse(
            positions_racmacs$type == "antigen",
            paste0("V/", positions_racmacs$name),
            paste0("S/", positions_racmacs$name)
          )
          
          rownames(positions_racmacs) <- positions_racmacs$name
          positions_racmacs <- positions_racmacs[,3:ncol(positions_racmacs)]
          
          # Calculate distances
          p_dist_mat <- coordinates_to_matrix(as.matrix(positions_racmacs))
          
          # Calculate errors
          racmacs_errors <- error_calculator_comparison(
            p_dist_mat = p_dist_mat,
            truth_matrix = truth_matrix,
            input_matrix = input_matrix
          )
          
          # Store this fold's metrics
          fold_mae[i] <- mean(abs(racmacs_errors$report_df$OutSampleError), na.rm = TRUE)
          fold_mape[i] <- mean(abs(racmacs_errors$report_df$OutSamplePercentageError), na.rm = TRUE)  # Added MAPE calculation
          fold_Completeness[i] <- racmacs_errors$Completeness
        }
        
        # Calculate averages across folds
        mean_mae <- mean(fold_mae, na.rm = TRUE)
        mean_mape <- mean(fold_mape, na.rm = TRUE)
        mean_Completeness <- mean(fold_Completeness, na.rm = TRUE)
        
        # Store dimension results
        dim_results <- rbind(
          dim_results,
          data.table(
            Dimension = test_dim,
            MAE = mean_mae,
            MAPE = mean_mape,
            Completeness = mean_Completeness * 100,  # Convert to percentage
            OriginalDimension = orig_dim,
            Variant = variant,
            Algorithm = "MDS"
          )
        )
        
        # Check stopping condition - stop when Completeness falls below 95%
        if(mean_Completeness < 0.95) {
          cat(sprintf("    Completeness below 95%% (%.2f%%) - stopping dimension testing\n", 
                    mean_Completeness * 100))
          continue_testing <- FALSE
        } else {
          test_dim <- test_dim + 1  # Test next dimension
        }
      }
    }
  }
  
  # Save dimension results
  results_file <- file.path(output_dir, "racmacs_dimensions_sim_data.csv")
  write.csv(dim_results, results_file, row.names = FALSE)
  cat(sprintf("\nResults saved to %s\n", results_file))
  
  return(dim_results)
}


# Plot Dimension Results with Highlighted Optimal Dimensions
#
# @param results The dimension results dataframe
# @param output_dir Directory to save plots
# @param optimal_dims Vector of 27 numbers indicating optimal dimension for each panel
# @return The improved faceted plot with highlighted optimal dimensions
#
# @details
# The optimal_dims parameter should contain 27 values in this order:
# - First grouped by original dimension (2D, 5D, 10D)
# - Then by completeness (70%, 85%, 95%)
# - Then by variant type (Missing Data, Noise, Noise+Bias)
#
# Example: optimal_dims[1] = optimal dimension for 2D original, 70% completeness, Missing Data
#          optimal_dims[2] = optimal dimension for 2D original, 70% completeness, Noise
#          optimal_dims[3] = optimal dimension for 2D original, 70% completeness, Noise+Bias
#          ...and so on
plot_dimension_results <- function(results, output_dir, optimal_dims = NULL) {
  plots_dir <- file.path(output_dir, "plots")
  if (!dir.exists(plots_dir)) {
    dir.create(plots_dir, recursive = TRUE)
  }
  
  # Get all unique combinations of original dimension and variant
  orig_dims <- sort(unique(results$OriginalDimension))
  all_variants <- sort(unique(results$Variant))
  
  # Organize variants by type and level
  variant_types <- c("missing", "noise1", "noise_bias")
  variant_levels <- c("S", "M", "L")
  
  # Create a list to store all individual plots
  individual_plots <- list()
  
  # Create plots for each combination
  for(orig_dim in orig_dims) {
    for(variant in all_variants) {
      # Get data for this specific dataset
      dataset_data <- results[results$OriginalDimension == orig_dim & 
                               results$Variant == variant, ]
      
      if(nrow(dataset_data) == 0) next
      
      # Filter data to only include points with Completeness > 95
      dataset_data <- dataset_data[dataset_data$Completeness > 95, ]
      if(nrow(dataset_data) == 0) next
      
      # Create plot focusing only on MAPE
      p <- ggplot(dataset_data, aes(x = Dimension)) +
        # MAPE line and points in black
        geom_line(aes(y = MAPE), color = "black", size = 0.8) +
        geom_point(aes(y = MAPE), color = "black", size = 1.5) +
        # Set up axes
        scale_y_continuous(name = "Validation MAPE (%)") +
        labs(
          x = "Dimension", 
          title = paste0(orig_dim, "D - ", 
                       gsub("^([SML])_([a-z]+).*$", "\\1-\\2", variant))
        ) +
        theme_minimal() +
        theme(
          panel.grid.minor = element_blank(),
          legend.position = "none",
          plot.title = element_text(size = 7, hjust = 0.5),
          axis.title = element_text(size = 6),
          axis.text = element_text(size = 6),
          plot.margin = margin(2, 2, 2, 2, "mm")
        )
      
      # Store the plot
      plot_key <- paste0("dim", orig_dim, "_", variant)
      individual_plots[[plot_key]] <- p
      
      # Save individual plot
      individual_file <- file.path(plots_dir, paste0(plot_key, ".pdf"))
      ggsave(individual_file, p, width = 2.5, height = 2, units = "in")
    }
  }
  
  # Prepare data for faceted plot
  plot_data <- results %>%
    # Filter to only include data with Completeness > 95
    filter(Completeness > 95) %>%
    # Map variant levels to completion percentages for faceting labels
    mutate(
      CompletenessLabel = case_when(
        grepl("^S_", Variant) ~ "70%",
        grepl("^M_", Variant) ~ "85%",
        grepl("^L_", Variant) ~ "95%",
        TRUE ~ NA_character_
      ),
      # Extract variant type
      VariantType = case_when(
        grepl("missing", Variant) ~ "Original",
        grepl("noise_bias", Variant) ~ "Noise+Bias",
        grepl("noise1", Variant) ~ "Noise",
        TRUE ~ NA_character_
      )
    ) %>%
    # Add dimension label for faceting
    mutate(DimensionLabel = paste0(OriginalDimension, "D"))
  
  # Create a combined dimension-completeness variable for 9 column facet layout
  plot_data <- plot_data %>%
    mutate(DimCompLabel = paste0(DimensionLabel, "-", CompletenessLabel))
  
  # Create proper ordering for the combined factor
  dim_comp_levels <- c()
  for (dim in paste0(sort(unique(results$OriginalDimension)), "D")) {
    for (comp in c("70%", "85%", "95%")) {
      dim_comp_levels <- c(dim_comp_levels, paste0(dim, "-", comp))
    }
  }
  
  # Ensure proper ordering
  plot_data$CompletenessLabel <- factor(plot_data$CompletenessLabel, 
                                levels = c("70%", "85%", "95%"))
  plot_data$VariantType <- factor(plot_data$VariantType, 
                                 levels = c("Original", "Noise", "Noise+Bias"))
  plot_data$DimensionLabel <- factor(plot_data$DimensionLabel,
                                    levels = paste0(sort(unique(results$OriginalDimension)), "D"))
  plot_data$DimCompLabel <- factor(plot_data$DimCompLabel, levels = dim_comp_levels)
  
  # Find the maximum dimension tested for setting x-axis breaks
  max_dim <- max(plot_data$Dimension)
  x_breaks <- seq(2, max_dim, by = 2)  # Even integers only
  
  # Create highlights data if optimal_dims is provided
  highlights_data <- NULL
  if (!is.null(optimal_dims)) {
    # Build reference table matching panel index to dimension, completeness, variant
    panel_idx <- 1
    highlights_data <- data.frame()
    
    for (dim in orig_dims) {
      for (comp in c("70%", "85%", "95%")) {
        for (vtype in c("Original", "Noise", "Noise+Bias")) {
          if (panel_idx <= length(optimal_dims) && !is.na(optimal_dims[panel_idx])) {
            # Find the corresponding data point
            subset_data <- plot_data %>%
              filter(
                OriginalDimension == dim,
                CompletenessLabel == comp,
                VariantType == vtype,
                Dimension == optimal_dims[panel_idx]
              )
            
            # If we found a match, add it to highlights
            if (nrow(subset_data) > 0) {
              highlights_data <- rbind(highlights_data, subset_data)
            }
          }
          panel_idx <- panel_idx + 1
        }
      }
    }
  }
  
  # Create the faceted plot with improved styling and 3×9 layout
  facet_plot <- ggplot(plot_data) +
    # Create facet grid with 3 rows (variant types) and 9 columns (dimension-completeness combinations)
    facet_grid(
      VariantType ~ DimCompLabel,
      scales = "free_y"
    ) +
    # MAPE line and points in black
    geom_line(aes(x = Dimension, y = MAPE), color = "black", size = 0.8) +
    geom_point(aes(x = Dimension, y = MAPE), color = "black", size = 1.5) +
    
    # Add highlights for optimal dimensions if provided
    {if (!is.null(highlights_data) && nrow(highlights_data) > 0)
      geom_point(data = highlights_data, 
                aes(x = Dimension, y = MAPE),
                color = "black", size = 2.5, shape = 21, 
                stroke = 1.2, fill = NA)
    } +
    
    scale_x_continuous(breaks = x_breaks) +  # Integer breaks only
    labs(
      #title = "RACMACS Dimensionality Analysis Across Synthetic Datasets",
      x = "Test Dimension",
      y = "Validation MAPE (%)"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(size = 6, face = "bold"),  # Smaller text for column labels
      strip.background = element_rect(fill = "gray95", color = NA),
      axis.title = element_text(size = 8),
      axis.text = element_text(size = 6),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_line(color = "gray90", size = 0.2),
      legend.position = "none",  # Remove legend
      panel.spacing = unit(0.5, "mm"),
      # Add black borders between panels
      panel.border = element_rect(color = "black", fill = NA, size = 0.2)
    )
  
  # Save the faceted plot with adjusted dimensions for 3×9 layout
  facet_file <- file.path(plots_dir, "faceted_dimension_analysis.pdf")
  ggsave(facet_file, facet_plot, width = 12, height = 6, units = "in")
  
  return(list(
    faceted_plot = facet_plot
  ))
}
```

```{r}
# script to run RACMACS dimensionality analysis with early stopping

# Run the analysis
dim_results <- find_optimal_racmacs_dimensions(
  sim_data = sim_data,  # The sim_data from generate_synthetic_datasets 
  matrix_variants = matrix_variants,  # From the input setup
  opt_setting = opt_params,  # From the input setup 
  output_dir = output_dir  # From the input setup
)

```

```{r}
# Generate plots
racmacs_dimensions_sim_data <- read.csv("synthetic_data/racmacs_dimensions_sim_data.csv")

#  optimal dimensions of RACMACS
RACMACS_optimal_dims <- c(
  # 2D original dimension
  2, 2, 2,  # 70% (Missing, Noise, Noise+Bias)
  2, 2, 2,  # 85% (Missing, Noise, Noise+Bias)
  2, 2, 2,  # 95% (Missing, Noise, Noise+Bias)
  
  # 5D original dimension
  4, 4, 2,  # 70% (Missing, Noise, Noise+Bias)
  4, 4, 4,  # 85% (Missing, Noise, Noise+Bias)
  2, 2, 2,  # 95% (Missing, Noise, Noise+Bias)
  
  # 10D original dimension
  4, 4, 4,  # 70% (Missing, Noise, Noise+Bias)
  4, 4, 4,  # 85% (Missing, Noise, Noise+Bias)
  3, 3, 3   # 95% (Missing, Noise, Noise+Bias)
)

all_plots <- plot_dimension_results(results = racmacs_dimensions_sim_data, output_dir, RACMACS_optimal_dims)

# Output a summary of findings
cat("\n----- Summary of Optimal Dimensions -----\n")
# Group by original dimension and variant, find where Completeness drops below 95%
summary_table <- racmacs_dimensions_sim_data %>%
  group_by(OriginalDimension, Variant) %>%
  arrange(OriginalDimension, Variant, Dimension) %>%
  filter(Completeness < 95) %>%
  slice(1) %>%
  mutate(LastGoodDimension = Dimension - 1) %>%
  select(OriginalDimension, Variant, LastGoodDimension, Completeness) %>%
  arrange(OriginalDimension, Variant)

print(summary_table)
```


##Setup Result Collection:

Initialize data structures to collect performance metrics.
We run RACMACS in 2D and in the same dim as Topolow (the optimal dimensionality found by Topolow)

```{r}
# Initialize Topolow results dataframes
topolow_errors_df <- data.table(
  InSampleError = numeric(),
  OutSampleError = numeric(),
  InSamplePercentageError = numeric(),
  OutSamplePercentageError = numeric(),
  Dimension = numeric(),
  Algorithm = character(),
  Scenario = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

topolow_mapped_objects_df <- data.table(
  Dimension = numeric(),
  Mapped = numeric(),
  Total = numeric(),
  Validation_Completeness = numeric(),
  Algorithm = character(),
  Scenario = character(), 
  Fold = numeric(),
  stringsAsFactors = FALSE
)

# Initialize racmacs results tables

racmacs_errors_df <- data.table(
  InSampleError = numeric(),
  OutSampleError = numeric(), 
  InSamplePercentageError = numeric(),
  OutSamplePercentageError = numeric(),
  Dimension = numeric(),
  Algorithm = character(),
  Scenario = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

racmacs_Completeness <- data.table(
  Dimension = numeric(),
  Mapped = numeric(),
  Total = numeric(), 
  Validation_Completeness = numeric(),
  Algorithm = character(),
  Scenario = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

```


## Run Comparison

Now we'll run both algorithms for each fold:

```{r eval=FALSE}
cc=0 # scenario counter
# Process each dimension
for (original_dim in sim_data$metadata$dimension) {
  dim_data <- sim_data$matrices[[which(sim_data$metadata$dimension == original_dim)]]
  
  # Process each matrix variant
  for (matrix_type in matrix_variants) {
    cc = cc+1
    scenario_name <- sprintf("dim%d_%s", original_dim, matrix_type)
    
    # Get optimal parameters for this scenario
    # For topolow:
    best_params <- opt_params$topolow_params %>%
      filter(true_dim == original_dim, matrix_type == !!matrix_type)
    
    if (nrow(best_params) == 0) {
      warning("No optimal parameters found for scenario: ", scenario_name)
      next
    }
    
    # Convert parameters to expected format
    best_params <- list(
      N = round(exp(best_params$log_N)),
      k0 = exp(best_params$log_k0),
      cooling_rate = exp(best_params$log_cooling_rate),
      c_repulsion = exp(best_params$log_c_repulsion)
    )
    
    # For RACMACS
    # Convert matrix_type to indices
    matrix_type_parts <- strsplit(matrix_type, "_")[[1]]
    percentage <- substr(matrix_type_parts[1], 1, 1)  # S, M, or L
    type <- paste(matrix_type_parts[-1], collapse="_")  # missing, noise1, noise_bias
    
    # Determine indices
    dim_index <- match(original_dim, c(2, 5, 10)) - 1
    pct_index <- match(percentage, c("S", "M", "L")) - 1
    type_index <- if(grepl("missing", type)) {
      0
    } else if(grepl("noise1", type)) {
      1
    } else if(grepl("noise_bias", type)) {
      2
    } else {
      stop("Unknown matrix type: ", type)
    }
    
    # Calculate the index into RACMACS_optimal_dims
    racmacs_dim_index <- dim_index * 9 + pct_index * 3 + type_index + 1
    optimal_dim <- RACMACS_optimal_dims[racmacs_dim_index]
    #
    
    # Get truth matrix and corresponding no-noise truth if needed
    truth_matrix <- dim_data[[matrix_type]]
    no_noise_truth <- if(grepl("noise|bias", matrix_type)) {
      dim_data[[sub("_noise.*|_bias.*", "_missing", matrix_type)]]
    } else {
      NULL
    }
    
    # Create CV folds 
    matrix_list <- create_cv_folds(
      truth_matrix = truth_matrix,
      no_noise_truth = no_noise_truth,
      n_folds = opt_params$n_folds,
    )
    
    # Save matrix list for SLURM jobs
    if (opt_params$use_slurm) {
      matrix_file <- file.path(matrix_dir,
                               sprintf("%s_matrices.rds", scenario_name))
      saveRDS(matrix_list, matrix_file)
    }
    
    # Run comparison for each fold
    for(i in seq_len(opt_params$n_folds)) {
      
      
      
      #           ##################Topolow#####################


      if (opt_params$use_slurm) {
        # Submit Topolow job to SLURM
        args_list <- c(
          normalizePath(matrix_file),
          as.character(best_params$N),
          as.character(opt_params$max_topolow_iter),
          as.character(best_params$k0),
          as.character(best_params$cooling_rate),
          as.character(best_params$c_repulsion),
          scenario_name,
          as.character(i),
          as.character(topolow_results_dir)
        )

        slurm_script <- create_slurm_script(
          job_name = sprintf("%d_comparison_topolow_%s", i, scenario_name),
          script_path = system.file("scripts/run_topolow_comparison.R",
                                    package = "topolow"),
          args = args_list,
          num_cores = 21,
          time = "5:00:00",
          memory = "1G",
          output_file = file.path(topolow_results_dir,
                                  sprintf("%s_fold%d.out", scenario_name, i)),
          error_file = file.path(topolow_results_dir,
                                 sprintf("%s_fold%d.err", scenario_name, i))
        )

        submit_job(slurm_script, use_slurm = opt_params$use_slurm,
                   cider = TRUE)
      } else{
        cat(sprintf("\n#####################\n##Scenario %d out of %d \n", cc, length(sim_data$metadata$dimension)*length(matrix_variants)))
        # Run Topolow locally and collect results in same format as RACMACS
        truth_matrix <- matrix_list[[i]][[1]]
        input_matrix <- matrix_list[[i]][[2]]

        # Run Topolow optimization
        result <- create_topolow_map(
          distance_matrix = input_matrix,
          ndim = best_params$N,
          mapping_max_iter = opt_params$max_topolow_iter,
          k0 = best_params$k0,
          cooling_rate = best_params$cooling_rate,
          c_repulsion = best_params$c_repulsion,
          write_positions_to_csv = FALSE,
          verbose = FALSE
        )

        p_dist_mat <- result$est_distances

        # Calculate performance metrics
        topolow_errors <- error_calculator_comparison(
          p_dist_mat = p_dist_mat,
          truth_matrix = truth_matrix,
          input_matrix = input_matrix
        )

        # Store error results
        topolow_df <- topolow_errors$report_df
        topolow_df$Dimension <- best_params$N
        topolow_df$Algorithm <- "Topolow"
        topolow_df$Scenario <- scenario_name
        topolow_df$Fold <- i
        topolow_errors_df <- rbind(topolow_errors_df, topolow_df)

        # Store Completeness results
        topolow_mapped_objects_df <- rbind(
          topolow_mapped_objects_df,
          data.table(
            Dimension = best_params$N,
            Mapped = nrow(p_dist_mat),
            Total = nrow(truth_matrix),
            Validation_Completeness = topolow_errors$Completeness,
            Algorithm = "Topolow",
            Scenario = scenario_name,
            Fold = i
          )
        )
      }
      
      
                #################RACMACS ######################
      
      cat(sprintf("Scenario %d out of %d \n", cc, length(sim_data$metadata$dimension)*length(matrix_variants)))

      # Run RACMACS locally
      truth_matrix <- matrix_list[[i]][[1]]
      input_matrix <- matrix_list[[i]][[2]]

      # Convert to titer format for RACMACS
      titer_table <- dist_to_titer_table(input_matrix, base=2, tens=10)

      # Run RACMACS optimization
      map <- create_and_optimize_RACMACS_map(
        titer_table = titer_table,
        dim = optimal_dim,  # Use the optimal dimension
        optimization_number = opt_params$racmacs_opt_rounds,
        num_cores = opt_params$num_cores,
        scenario_name = scenario_name
      )

      save.coords(map, filename = "RACMACS_coords.csv",
                 optimization_number = 1, antigens = TRUE, sera = TRUE)

      # Process RACMACS results
      positions_racmacs <- read.csv("RACMACS_coords.csv")
      #positions_racmacs <- na.omit(positions_racmacs)
      count_mapped_rows <- positions_racmacs %>%
        filter(rowSums(is.na(.)) == 0) %>%
        nrow()

      positions_racmacs <- positions_racmacs %>%
        mutate(name = case_when(
          type == "antigen" ~ paste0("V/", name),
          type == "sera" ~ paste0("S/", name),
          TRUE ~ name
        ))

      rownames(positions_racmacs) <- positions_racmacs$name
      positions_racmacs <- positions_racmacs[,3:ncol(positions_racmacs)]

      # Calculate performance metrics
      p_dist_mat <- coordinates_to_matrix(as.matrix(positions_racmacs))

      racmacs_errors <- error_calculator_comparison(
        p_dist_mat = p_dist_mat,
        truth_matrix = truth_matrix,
        input_matrix = input_matrix
      )

      # Store results
      racmacs_df <- racmacs_errors$report_df
      racmacs_df$Dimension = optimal_dim
      racmacs_df$Algorithm = "MDS"
      racmacs_df$Scenario = scenario_name
      racmacs_df$Fold <- i
      racmacs_errors_df <- rbind(racmacs_errors_df, racmacs_df)

      racmacs_Completeness <- rbind(
        racmacs_Completeness,
        data.table(
          Dimension = optimal_dim,
          Mapped = count_mapped_rows,
          Total = nrow(truth_matrix),
          Validation_Completeness = racmacs_errors$Completeness,
          Algorithm = "MDS",
          Scenario = scenario_name,
          Fold = i
        )
      )
      
    }
  }
}

# Save results
write.csv(topolow_errors_df,"Topolow_comparisondf.csv",
          row.names = FALSE)

write.csv(topolow_mapped_objects_df, "Topolow_mapped_objects.csv",
          row.names = FALSE)

write.csv(racmacs_errors_df,"RACMACS_comparisondf.csv",
          row.names = FALSE)

write.csv(racmacs_Completeness, "RACMACS_mapped_objects.csv",
          row.names = FALSE)

```


##Collect and Aggregate Results

After all Topolow jobs complete, collect and analyze results:

```{r}
# Read the CSV files back into dataframes
racmacs_errors_df <- read.csv("RACMACS_comparisondf.csv")
racmacs_Completeness <- read.csv("RACMACS_mapped_objects.csv")

topolow_errors_df <- read.csv("Topolow_comparisondf.csv")
topolow_mapped_objects_df <- read.csv("Topolow_mapped_objects.csv")
```

```{r}
## If SLURM was used:
# Collect Topolow results from SLURM output


# directory_path <- "results"
# 
# # Errors
# pattern <- paste0("_errors", "\\.csv$")
# csv_files <- list.files(path = directory_path, pattern = pattern, 
#                        full.names = TRUE)
# topolow_errors_df <- rbindlist(lapply(csv_files, fread), 
#                            use.names = TRUE, fill = TRUE)
# 
# # Completeness
# pattern <- paste0("_Completeness", "\\.csv$")
# csv_files <- list.files(path = directory_path, pattern = pattern,
#                        full.names = TRUE)
# topolow_mapped_objects_df <- rbindlist(lapply(csv_files, fread),
#                                      use.names = TRUE, fill = TRUE)
# 
```


##Analyze Results

Calculate summary statistics for both algorithms:

```{r}
# Calculate MAE and SD across folds
get_scenario_stats <- function(errors, metric) {
  fold_stats <- aggregate(
    as.formula(paste(metric, "~ Scenario + Fold")),
    data = errors,
    FUN = function(x) mean(abs(x), na.rm = TRUE) 
  ) 
  scenario_stats <- aggregate(
    as.formula(paste(metric, "~ Scenario")),
    data = fold_stats,
    FUN = function(x) c(mean = mean(x, na.rm = TRUE), sd = sd(x, na.rm = TRUE))
  )

  # Split the combined mean and sd into separate columns
  scenario_stats <- do.call(data.frame, scenario_stats)
  colnames(scenario_stats)[2:3] <- c("Mean", "SD")
  
  return(scenario_stats)
}

# RACMACS results
racmacs_mae_stats <- get_scenario_stats(racmacs_errors_df, metric = "OutSampleError")
racmacs_mape_stats <- get_scenario_stats(racmacs_errors_df, metric = "OutSamplePercentageError")
racmacs_Completeness_stats <- get_scenario_stats(racmacs_Completeness, metric = "Mapped")

# Topolow results  
topolow_mae_stats <- get_scenario_stats(topolow_errors_df, metric = "OutSampleError")
topolow_mape_stats <- get_scenario_stats(topolow_errors_df, metric = "OutSamplePercentageError")
topolow_Completeness_stats <- get_scenario_stats(topolow_mapped_objects_df, metric = "Mapped")

# Add the new columns
add_columns <- function(df, Method) {
  df <- df %>%
    mutate(
      Dimension = as.numeric(sub("dim(\\d+)_.*", "\\1", Scenario)),
      Missing = case_when(
        grepl("_S_", Scenario) ~ "70%",
        grepl("_M_", Scenario) ~ "85%",
        grepl("_L_", Scenario) ~ "95%"
      ),
      Variant = case_when(
        grepl("_missing$", Scenario) ~ "Original",
        grepl("_noise1$", Scenario) ~ "+Noise",
        grepl("_noise_bias$", Scenario) ~ "+Noise+Bias"
      ),
      Method = Method
    )
  return(df)
}

racmacs_mae_stats <- add_columns(racmacs_mae_stats, Method="MDS")
racmacs_mape_stats <- add_columns(racmacs_mape_stats, Method="MDS")
racmacs_Completeness_stats <- add_columns(racmacs_Completeness_stats, Method="MDS")

topolow_mae_stats <- add_columns(topolow_mae_stats, Method="Topolow")
topolow_Completeness_stats <- add_columns(topolow_Completeness_stats, Method="Topolow")
topolow_mape_stats <- add_columns(topolow_mape_stats, Method="Topolow")
```


##Visualization

```{r}
all_mape_results <- rbind(topolow_mape_stats, racmacs_mape_stats)
all_mape_results <- all_mape_results %>% dplyr::mutate(MAPE=Mean)
all_mape_results$Variant <- factor(all_mape_results$Variant, 
                                 levels = c("Original", "+Noise", "+Noise+Bias"))


# Create MAPE plot
p <- ggplot(all_mape_results, aes(x = Missing, y = MAPE, fill = Method)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = MAPE - SD, ymax = MAPE + SD),
                position = position_dodge(width = 0.9), width = 0.25) +
  facet_grid(Dimension ~ Variant, 
             labeller = labeller(Dimension = function(x) paste("Dim. =", x))) +
  scale_fill_manual(values = c("Topolow" = "#4dbedf", "MDS" = "#e59572")) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 6),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_text(size = 6),
    strip.text = element_text(size = 6, face = "bold"),
    strip.background = element_rect(fill = "gray95"),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6),
    legend.key.size = unit(0.8, "lines"),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  ) +
  labs(
    x = "Missing Data Level",
    y = "Validation MAPE (±SD)"
  )

# Save plot
ggsave("Method_comparison_MAPE_plot_250points.pdf", plot = p, width = 172, height = 0.5*172, units = "mm", dpi = 300)

print(p)
```


```{r}
all_mae_results <- rbind(topolow_mae_stats, racmacs_mae_stats)
all_mae_results <- all_mae_results %>% dplyr::mutate(MAE=Mean)

all_mae_results$Variant <- factor(all_mae_results$Variant, 
                                  levels = c("Original", "+Noise", "+Noise+Bias"))

p <- ggplot(all_mae_results, aes(x = Missing, y = MAE, fill = Method)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = MAE - SD, ymax = MAE + SD),
                position = position_dodge(width = 0.9), width = 0.25) +
  facet_grid(Dimension ~ Variant, 
             labeller = labeller(Dimension = function(x) paste("Dim. =", x))) +
  scale_fill_manual(values = c("Topolow" = "#4dbedf", "MDS" = "#e59572")) +
  theme_minimal() +
  theme(
    # Axis text
    axis.title = element_text(size = 6),
    axis.text.x = element_text(size = 5), #, angle = 45, hjust = 1
    axis.text.y = element_text(size = 5),
    
    # Panel labels and strips
    strip.text = element_text(size = 6, face = "bold"),
    strip.background = element_rect(fill = "gray95"),
    
    # Legend
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 5),
    legend.key.size = unit(0.8, "lines"),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  ) +
  labs(
    x = "Missing Data Level",
    y = "Validation MAE (±SD)"
  )

# Save with adjusted dimensions to accommodate smaller text
ggsave("Method_comparison_MAE_plot_250points.pdf", plot = p, width = 172, height = 0.5*172, units = "mm", dpi = 300)

print(p)
```


## Summary table

```{r}
# Create summary table
summary_table <- all_mape_results %>%
  mutate(
    MAPE_SD = sprintf("%.3f ± %.3f", MAPE, SD)
  ) %>%
  select(Dimension, Missing, Variant, Method, MAPE_SD) %>%
  spread(Method, MAPE_SD)

# Create and save the LaTeX table
latex_table <- knitr::kable(summary_table, 
                           caption = "Performance across complexity and missingness levels (MAPE +- SD). Supporting information for Figure ",
                           format = "latex",
                           booktabs = TRUE,
                           align = rep('c', ncol(summary_table)))

# Print the LaTeX code
cat(latex_table)
```


```{r}
all_Completeness_results <- bind_rows(topolow_Completeness_stats, racmacs_Completeness_stats)

# Create summary table of Completeness
summary_table_cov <- all_Completeness_results %>%
  group_by(Dimension, Missing, Method) %>%
  summarize(Mean = mean(Mean), .groups = 'drop') %>%
  spread(Method, Mean)

summary_table_cov$MDS <- round(summary_table_cov$MDS)
# Create and save LaTeX table to a variable
latex_table <- knitr::kable(summary_table_cov,
                           caption = "Count of mapped antigens/antisera",
                           format = "latex",
                           booktabs = TRUE,
                           align = rep('c', ncol(summary_table_cov)))

# To view the table (optional)
cat(latex_table)
```


### Statistical Analysis

```{r}
# Calculate MAE and SD across folds
get_fold_stats <- function(errors, metric) {
  fold_stats <- aggregate(
    as.formula(paste(metric, "~ Scenario + Fold")),
    data = errors,
    FUN = function(x) mean(abs(x), na.rm = TRUE) 
  ) 

  # Split the combined mean and sd into separate columns
  fold_stats <- do.call(data.frame, fold_stats)
  colnames(fold_stats)[3] <- c("MAPE")
  
  return(fold_stats)
}


# RACMACS results
racmacs_ttest <- get_fold_stats(racmacs_errors_df, metric = "OutSamplePercentageError")
racmacs_ttest$Method <- "MDS"

# Topolow results  
topolow_ttest <- get_fold_stats(topolow_errors_df, metric = "OutSamplePercentageError")
topolow_ttest$Method <- "Topolow"

# Aggregate and add necessary columns
all_ttest <- rbind(racmacs_ttest, topolow_ttest)
all_ttest <- add_columns(all_ttest)

# Perform paired t-tests for each condition
stat_tests <- all_ttest %>%
  group_by(Dimension, Missing, Variant) %>%
  summarize(
    t_stat = t.test(MAPE[Method == "MDS"],
                    MAPE[Method == "Topolow"],
                    paired = TRUE)$statistic,
    p_value = t.test(MAPE[Method == "MDS"],
                     MAPE[Method == "Topolow"],
                     paired = TRUE)$p.value,
    .groups = 'drop'
  ) %>%
  mutate(
    #significant = p_value < 0.05,
    Sig.Level = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**", 
      p_value < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  )


# Create and save LaTeX table to a variable
latex_table <- knitr::kable(stat_tests,
                            caption = "Statistical Significance Tests",
                           format = "latex",
                           booktabs = TRUE,
                           align = rep('c', ncol(stat_tests)))

# To view the table (optional)
cat(latex_table)
```

### Distribution of errors

```{r}
# Calculate MAE and SD across folds
get_scenario_distribution <- function(errors, metric) {
  scenario_stats <- aggregate(
    as.formula(paste(metric, "~ Scenario")),
    data = errors,
    FUN = function(x) c(mean(x, na.rm = TRUE), sd = sd(x, na.rm = TRUE)) 
  ) 

  # Split the combined mean and sd into separate columns
  scenario_stats <- do.call(data.frame, scenario_stats)
  colnames(scenario_stats)[2:3] <- c("MAE", "SD")
  
  return(scenario_stats)
}

racmacs_e_stats <- get_scenario_distribution(racmacs_errors_df, metric = "OutSampleError")
topolow_e_stats <- get_scenario_distribution(topolow_errors_df, metric = "OutSampleError")

racmacs_e_stats <- add_columns(racmacs_e_stats, Method="MDS")
topolow_e_stats <- add_columns(topolow_e_stats, Method="Topolow")

all_e_stats <- rbind(racmacs_e_stats, topolow_e_stats)

# Create summary table
summary_table <- all_e_stats %>%
  mutate(
    ME_SD = sprintf("%.3f ± %.3f", MAE, SD)
  ) %>%
  select(Dimension, Missing, Variant, Method, ME_SD) %>%
  spread(Method, ME_SD)

# Create and save LaTeX table to a variable
latex_table <- knitr::kable(summary_table,
                            caption = "Distribution of errors (Mean ± SD)",
                           format = "latex",
                           booktabs = TRUE,
                           align = rep('c', ncol(summary_table)))

# To view the table (optional)
cat(latex_table)
```

### Error reduction in noisy inputs

```{r}
# Calculate error reduction analysis
error_reduction_analysis <- function(ndim, scenario_variant, method_errors, results) {
  # Construct full scenario name
  scenario_name <- sprintf("dim%d_%s", ndim, scenario_variant)
  
  # Get corresponding matrices
  noisy_matrix <- results$matrices[[which(results$metadata$dimension == ndim)]][[scenario_variant]]
  missing_matrix_name <- sub("_noise.*|_bias.*", "_missing", scenario_variant)
  missing_matrix <- results$matrices[[which(results$metadata$dimension == ndim)]][[missing_matrix_name]]
  
  # Calculate mean difference between matrices
  noisy_input_MAPE <- 100*mean(abs((noisy_matrix - missing_matrix)/missing_matrix), na.rm = TRUE)
  
  # Calculate mean Topolow error for this scenario
  method_errors <- method_errors[method_errors$Scenario == scenario_name,]
  method_MAPE <- mean(abs(ifelse(is.na(method_errors$InSamplePercentageError), 
                           method_errors$OutSamplePercentageError,
                           method_errors$InSamplePercentageError)), 
                    na.rm = TRUE)
  
  return(c(noisy_input_MAPE = noisy_input_MAPE, method_MAPE = method_MAPE))
}

# Get scenarios to analyze
noise_variants <- c("S_noise1", "S_noise_bias", "M_noise1", "M_noise_bias", 
                   "L_noise1", "L_noise_bias")

# Initialize results dataframe
error_reduction <- data.frame(
  Dimension = numeric(),
  Scenario = character(),
  noisy_input_Error = numeric(),
  Topolow_Error = numeric(),
  MDS_Error = numeric(),
  stringsAsFactors = FALSE
)

# Calculate error reduction for each dimension and scenario
for (ndim in sim_data$metadata$dimension) {
  for (variant in noise_variants) {
    topo <- error_reduction_analysis(ndim, variant, topolow_errors_df, sim_data)
    mds <- error_reduction_analysis(ndim, variant, racmacs_errors_df, sim_data)
    error_reduction <- rbind(error_reduction, 
                          data.frame(
                            Dimension = ndim,
                            Scenario = variant,
                            noisy_input_Error = topo["noisy_input_MAPE"],
                            Topolow_Error = topo["method_MAPE"],
                            MDS_Error = mds["method_MAPE"]))
  }
}

# Add descriptive columns
error_reduction <- error_reduction %>%
  mutate(
    Missing = case_when(
      grepl("^S_", Scenario) ~ "70%",
      grepl("^M_", Scenario) ~ "85%", 
      grepl("^L_", Scenario) ~ "95%"
    ),
    Variant = ifelse(grepl("_noise1$", Scenario), "+Noise", "+Noise+Bias")
  ) %>%
  select(Dimension, Missing, Variant, noisy_input_Error, MDS_Error, Topolow_Error)

names(error_reduction)[4:6] <- c("Input", "MDS", "Topolow")
rownames(error_reduction) <- NULL


# Create and save LaTeX table to a variable
latex_table <- knitr::kable(error_reduction,
                           caption = "Error Reduction Analysis",
                           digits = 3,
                           format = "latex",
                           booktabs = TRUE,
                           align = rep('l', ncol(error_reduction)))

# To view the table (optional)
cat(latex_table)
```


## Antigenic maps

```{r}
# Create visualization configurations
dim_config <- new_dim_reduction_config(
  method = "pca",
  n_components = 2,
  scale = FALSE
)

aesthetic_config <- new_aesthetic_config(
  point_shapes = c(antigen = 16, antiserum = 4),
  point_size = 1.9,
  point_alpha = 0.65,
  color_palette = P60,
  gradient_colors = list(low = "blue", high = "red"),
  title_size = 8,
  subtitle_size = 7,
  axis_title_size = 7,
  axis_text_size = 6,
  legend_text_size =  7,
  legend_title_size = 7,
  show_legend = FALSE,
  legend_position = "none",
  show_title = FALSE
)

layout_config <- new_layout_config(
  panel_border = TRUE,
  width = 6.77165,
  height = 6,
  dpi = 300,
  reverse_x = 1,
  x_limits = c(-15, 13),
  y_limits = c(-50, 50),
  # x_limits = c(-3.1, 3.1),
  # y_limits = c(-3, 4),
  plot_margin = margin(0.05, 0.05, 0.05, 0.05, "cm"),
  save_format = "pdf"
)
```


### original data
```{r}
for(ndim in sim_data$metadata$dimension) {
  # Map the original coordinates
  original_coords <- sim_data$coordinates[[which(sim_data$metadata$dimension == ndim)]]
  original_coords$name <- original_coords$unique_id
  # Assign new column names to the first ndim columns
  col_names <- paste0("V", 1:ndim)
  colnames(original_coords)[1:ndim] <- col_names

  # Add antigen/antiserum indicators based on rownames
  original_coords$antigen <- startsWith(original_coords$name, "V/")
  original_coords$antiserum <- startsWith(original_coords$name, "S/")
  # Extract year from names - assuming format like "V/strain/year" or "S/strain/year"
  original_coords$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", original_coords$name))

  original_coords$name <- sub("^S/", "", original_coords$name)
  original_coords$name <- sub("^V/", "", original_coords$name)

  # Create and save temporal plot
  temporal_plot <- plot_temporal_mapping(
    original_coords,
    ndim = ndim,
    dim_config = dim_config,
    aesthetic_config = aesthetic_config,
    layout_config = layout_config
  )

  ggsave(
    file.path(plots_dir,
             sprintf("original_temporal_map_dim%d.pdf", ndim)),
    temporal_plot,
    width = layout_config$width,
    height = layout_config$height,
    dpi = layout_config$dpi
  )
}
```

```{r}
# First modify aesthetic configs for different legend handling
aesthetic_config_with_legend <- aesthetic_config
aesthetic_config_with_legend$show_legend <- TRUE
aesthetic_config_with_legend$legend_position <- "right"

aesthetic_config_no_legend <- aesthetic_config
aesthetic_config_no_legend$show_legend <- FALSE
aesthetic_config_no_legend$legend_position <- "none"

# Create plots
plots <- list()
for (i in 1:3) {
  ndim <- sim_data$metadata$dimension[i]
  
  # Get coordinates for this dimension
  original_coords <- sim_data$coordinates[[which(sim_data$metadata$dimension == ndim)]]
  original_coords$name <- original_coords$unique_id
  
  # Assign column names
  col_names <- paste0("V", 1:ndim)
  colnames(original_coords)[1:ndim] <- col_names
  
  # Add indicators and extract year
  original_coords$antigen <- startsWith(original_coords$name, "V/")
  original_coords$antiserum <- startsWith(original_coords$name, "S/")
  original_coords$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", original_coords$name))
  original_coords$name <- sub("^[VS]/", "", original_coords$name)
  
  # Create plot with or without legend
  aesthetic_config_to_use <- if(i == 3) aesthetic_config_with_legend else aesthetic_config_no_legend
  
  plots[[i]] <- plot_temporal_mapping(
    original_coords,
    ndim = ndim,
    dim_config = dim_config,
    aesthetic_config = aesthetic_config_to_use,
    layout_config = layout_config
  ) + 
    ggtitle(sprintf("%dD", ndim))  # Add dimension as title
}

# Create combined plot
combined_plot <- plot_grid(
  plots[[1]], plots[[2]], plots[[3]],
  labels = c("A. Dim=2", "B. Dim=5", "C. Dim=10"),
  label_size = 8,
  nrow = 1,
  align = 'h',
  axis = 'tb',
  rel_widths = c(1, 1, 1.6)  # Make the last panel slightly wider to accommodate legend
)

# Save combined plot
save_plot(
  file.path(plots_dir, "combined_temporal_plots.pdf"),
  combined_plot,
  ncol = 3,
  nrow = 1,
  base_width = layout_config$width/3.2,  # or Slightly wider to accommodate legend
  base_height = layout_config$height
)
```

### Topolow vs MDS on 10D scenarios

Run this block after previous block.

```{r}
ndim = sim_data$metadata$dimension[3]
matrix_type = matrix_variants[9]
# Get scenario names
base_scenario <- sprintf("synthetic_dim%d_%s", ndim, matrix_type)
# Get the matrices for this dimension
dim_data <- sim_data$matrices[[which(sim_data$metadata$dimension == ndim)]][[14]]


# Topolow plot:

topolow_coords_file <- file.path(coords_dir, 
                             sprintf("coords_dim%d_%s.csv", ndim, matrix_type))

positions_df <- read.csv(topolow_coords_file)
positions_df$name <- positions_df$X
# Add antigen/antiserum indicators based on rownames
positions_df$antigen <- startsWith(positions_df$name, "V/")
positions_df$antiserum <- startsWith(positions_df$name, "S/")
# Extract year from names - assuming format like "V/strain/year" or "S/strain/year"
positions_df$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", positions_df$name))

positions_df$name <- sub("^S/", "", positions_df$name)
positions_df$name <- sub("^V/", "", positions_df$name)

# Get the optimal parameters
amc_files <- c(
  file.path("model_parameters",
            sprintf("synthetic_dim%d_%s_model_parameters.csv", 
                   ndim, matrix_type)),
  file.path("model_parameters",
            sprintf("synthetic_MC2_dim%d_%s_model_parameters.csv", 
                   ndim, matrix_type)),
  file.path("model_parameters",
            sprintf("synthetic_MC7_dim%d_%s_model_parameters.csv", 
                   ndim, matrix_type))
)

# Combine chain results
amc_results <- do.call(rbind, lapply(amc_files, read.csv))
amc_results <- amc_results %>%
  filter(is.finite(NLL) & is.finite(Holdout_MAE)) %>%
  na.omit()
amc_results <- amc_results[amc_results$log_N >= log(2),]
amc_results <- as.data.frame(lapply(amc_results, clean_data, k = 4))
amc_results <- na.omit(amc_results)

# Find best parameters (minimum NLL)
optimal_params <- amc_results[which.min(amc_results$Holdout_MAE),]
optimal_params <- list(
  N = round(exp(as.numeric(optimal_params$log_N))),
  k0 = exp(as.numeric(optimal_params$log_k0)),
  cooling_rate = exp(as.numeric(optimal_params$log_cooling_rate)),
  c_repulsion = exp(as.numeric(optimal_params$log_c_repulsion))
)
    
# Create and save temporal plot
topolow_temporal_plot <- plot_temporal_mapping(
  positions_df,
  ndim = optimal_params$N,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config_no_legend,
  layout_config = layout_config
)


# RACMACS map

# Process RACMACS results
RACMACS_coords_file <- file.path(coords_dir, 
                       sprintf("RACMACS_coords_dim%d_%s.csv", ndim, matrix_type))
positions_racmacs <- read.csv(RACMACS_coords_file)
positions_racmacs <- na.omit(positions_racmacs)

positions_racmacs <- positions_racmacs %>%
  mutate(name = case_when(
    type == "antigen" ~ paste0("V/", name),
    type == "sera" ~ paste0("S/", name),
    TRUE ~ name
  ))

positions_racmacs <- as.data.frame(positions_racmacs)
# Add antigen/antiserum indicators based on rownames
positions_racmacs$antigen <- startsWith(positions_racmacs$name, "V/")
positions_racmacs$antiserum <- startsWith(positions_racmacs$name, "S/")
# Extract year from names - assuming format like "V/strain/year" or "S/strain/year"
positions_racmacs$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", positions_racmacs$name))

positions_racmacs$name <- sub("^S/", "", positions_racmacs$name)
positions_racmacs$name <- sub("^V/", "", positions_racmacs$name)
positions_racmacs[c('V1', 'V2')] <- positions_racmacs[c('X', 'X.1')]

# Create and save temporal plot
RACMACS_temporal_plot <- plot_temporal_mapping(
  positions_racmacs,
  ndim = 2,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config_no_legend,
  layout_config = layout_config
)


# Create combined plot
combined_plot <- plot_grid(
  RACMACS_temporal_plot, topolow_temporal_plot, plots[[3]],
  labels = c("A. MDS result", "B. Topolow result", "C. Original data"),
  label_size = 7,
  nrow = 1,
  align = 'h',
  axis = 'tb',
  rel_widths = c(1, 1, 1.6)  # Make the last panel slightly wider to accommodate legend
)

# Save combined plot
save_plot(
  file.path(plots_dir, "topolow_racmacs_plots_10D_L_nb.pdf"),
  combined_plot,
  ncol = 3,
  nrow = 1,
  base_width = layout_config$width/3.2,  # or Slightly wider to accommodate legend
  base_height = layout_config$height,
  dpi = layout_config$dpi
)

```

### Topolow
Creating the maps by Topolow and their 2D projections
```{r}
for(ndim in sim_data$metadata$dimension) {
  # Get the matrices for this dimension
  dim_data <- sim_data$matrices[[which(sim_data$metadata$dimension == ndim)]]
  
  for(matrix_type in matrix_variants) { # 
    # Get scenario names
    base_scenario <- sprintf("synthetic_dim%d_%s", ndim, matrix_type)
    amc_scenario <- base_scenario
    
    # Get the optimal parameters
    amc_files <- c(
      file.path("model_parameters",
                sprintf("synthetic_dim%d_%s_model_parameters.csv", 
                       ndim, matrix_type)),
      file.path("model_parameters",
                sprintf("synthetic_MC2_dim%d_%s_model_parameters.csv", 
                       ndim, matrix_type)),
      file.path("model_parameters",
                sprintf("synthetic_MC7_dim%d_%s_model_parameters.csv", 
                       ndim, matrix_type))
    )
    
    # Combine chain results
    amc_results <- do.call(rbind, lapply(amc_files, read.csv))
    amc_results <- amc_results %>%
      filter(is.finite(NLL) & is.finite(Holdout_MAE)) %>%
      na.omit()
    amc_results <- amc_results[amc_results$log_N >= log(2),]
    amc_results <- as.data.frame(lapply(amc_results, clean_data, k = 4))
    amc_results <- na.omit(amc_results)

    # Find best parameters (minimum NLL)
    optimal_params <- amc_results[which.min(amc_results$Holdout_MAE),]
    optimal_params <- list(
      N = round(exp(as.numeric(optimal_params$log_N))),
      k0 = exp(as.numeric(optimal_params$log_k0)),
      cooling_rate = exp(as.numeric(optimal_params$log_cooling_rate)),
      c_repulsion = exp(as.numeric(optimal_params$log_c_repulsion))
    )
    
    # Get corresponding distance matrix
    distance_matrix <- dim_data[[matrix_type]]
    
    message(sprintf("\nFinding coordinates for %d dimensions and matrix type: %s", 
                   ndim, matrix_type))
    
    # Run topolow with error handling
    topo_result <- tryCatch({
      create_topolow_map(
        distance_matrix = distance_matrix,
        ndim = optimal_params$N,
        mapping_max_iter = 5000,
        relative_epsilon = 1e-10,
        convergence_counter = 5,
        k0 = optimal_params$k0,
        cooling_rate = optimal_params$cooling_rate,
        c_repulsion = optimal_params$c_repulsion,
        write_positions_to_csv = FALSE
      )
    }, error = function(e) {
      warning(sprintf("Error in optimization for dim %d, type %s: %s", 
                     ndim, matrix_type, e$message))
      return(NULL)
    })
    
    if(!is.null(topo_result)) {
      # Save coordinates
      coords_file <- file.path(coords_dir, 
                             sprintf("coords_dim%d_%s.csv", ndim, matrix_type))
      write.csv(as.data.frame(topo_result$positions), 
                coords_file, row.names = TRUE)
      
      #positions_df <- as.data.frame(topo_result$positions)
      positions_df <- read.csv(coords_file)
      positions_df$name <- positions_df$X
      # Add antigen/antiserum indicators based on rownames
      positions_df$antigen <- startsWith(positions_df$name, "V/")
      positions_df$antiserum <- startsWith(positions_df$name, "S/")
      # Extract year from names - assuming format like "V/strain/year" or "S/strain/year"
      positions_df$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", positions_df$name))
      
      positions_df$name <- sub("^S/", "", positions_df$name)
      positions_df$name <- sub("^V/", "", positions_df$name)

      # Create and save temporal plot
      temporal_plot <- plot_temporal_mapping(
        positions_df,
        ndim = optimal_params$N,
        dim_config = dim_config,
        aesthetic_config = aesthetic_config,
        layout_config = layout_config
      )
      
      ggsave(
        file.path(plots_dir,
                 sprintf("Topolow_temporal_map_dim%d_%s.pdf", ndim, matrix_type)),
        temporal_plot,
        width = layout_config$width,
        height = layout_config$height,
        dpi = layout_config$dpi
      )
    }
  }
}
```

### MDS

Creating the maps by MDS and their 2D maps

```{r eval=FALSE}
# 1- Creating the maps by MDS 
for(ndim in sim_data$metadata$dimension) {
  # Get the matrices for this dimension
  dim_data <- sim_data$matrices[[which(sim_data$metadata$dimension == ndim)]]
  
  for(matrix_type in matrix_variants) { # 
    # Get scenario names
    base_scenario <- sprintf("synthetic_dim%d_%s", ndim, matrix_type)
    
    # Get corresponding distance matrix
    distance_matrix <- dim_data[[matrix_type]]
    
    message(sprintf("\nFinding coordinates for %d dimensions and matrix type: %s", 
                   ndim, matrix_type))
    
    # Convert to titer format for RACMACS
    titer_table <- dist_to_titer_table(distance_matrix, base=2, tens=10)

    # Run RACMACS optimization
    map <- create_and_optimize_RACMACS_map(
      titer_table = titer_table,
      dim = 2,
      optimization_number = opt_params$racmacs_opt_rounds,
      num_cores = opt_params$num_cores,
      scenario_name = base_scenario
    )

    # Save coordinates
    coords_file <- file.path(coords_dir, 
                           sprintf("RACMACS_coords_dim%d_%s.csv", ndim, matrix_type))
      
    save.coords(map, filename = coords_file,
               optimization_number = 1, antigens = TRUE, sera = TRUE)

  }
}
```

```{r eval=FALSE}
# 2- plotting 2D maps
for(ndim in sim_data$metadata$dimension) {
  # Get the matrices for this dimension
  dim_data <- sim_data$matrices[[which(sim_data$metadata$dimension == ndim)]]
  
  for(matrix_type in matrix_variants) {
    # Process RACMACS results
    coords_file <- file.path(coords_dir, 
                           sprintf("RACMACS_coords_dim%d_%s.csv", ndim, matrix_type))
    positions_racmacs <- read.csv(coords_file)
    positions_racmacs <- na.omit(positions_racmacs)

    positions_racmacs <- positions_racmacs %>%
      mutate(name = case_when(
        type == "antigen" ~ paste0("V/", name),
        type == "sera" ~ paste0("S/", name),
        TRUE ~ name
      ))

    positions_racmacs <- as.data.frame(positions_racmacs)
    # Add antigen/antiserum indicators based on rownames
    positions_racmacs$antigen <- startsWith(positions_racmacs$name, "V/")
    positions_racmacs$antiserum <- startsWith(positions_racmacs$name, "S/")
    # Extract year from names - assuming format like "V/strain/year" or "S/strain/year"
    positions_racmacs$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", positions_racmacs$name))
    
    positions_racmacs$name <- sub("^S/", "", positions_racmacs$name)
    positions_racmacs$name <- sub("^V/", "", positions_racmacs$name)
    positions_racmacs[c('V1', 'V2')] <- positions_racmacs[c('X', 'X.1')]

    # Create and save temporal plot
    temporal_plot <- plot_temporal_mapping(
      positions_racmacs,
      ndim = 2,
      dim_config = dim_config,
      aesthetic_config = aesthetic_config,
      layout_config = layout_config
    )
    
    ggsave(
      file.path(plots_dir,
               sprintf("RACMACS_temporal_map_dim%d_%s.pdf", ndim, matrix_type)),
      temporal_plot,
      width = layout_config$width,
      height = layout_config$height,
      dpi = layout_config$dpi
    )
  }
}
```



```{r}
sessionInfo()
```
