---
title: "Comparing Topolow with RACMACS on simulated data"
author: "Omid Arhami"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Comparing Topolow with RACMACS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 6,
  warning = TRUE,
 message = TRUE,    # Show messages
  error = TRUE      # Continue on error
)
```

##Introduction

This vignette demonstrates how to perform a rigorous comparison between Topolow and RACMACS algorithms for antigenic cartography. We conduct k-fold cross-validation and evaluate performance using multiple metrics including mean absolute error (MAE), Mean Absolute Percentage Error (MAPE), and coverage.

You need the optimal parameters to create topolow maps. They are in csv files named "optimal_parameters_80points.csv" or "optimal_parameters_250points.csv" which are provided on Github or you can generate them by running sufficient Monte Carlo simulations (on a machine with tens of CPU cores for faster calculations) in file synthetic-parameter-fitting.Rmd in the same folder is current file.

##Setup

First, we'll load required packages and set parameters:

```{r}
library(topolow)
library(Racmacs)
library(data.table)
library(dplyr)
library(parallel)
library(ggplot2)
library(tidyr)
library(gridExtra)
library(cowplot)

# Parameters

# Setup optimization parameters
opt_params <- list(
  n_folds = 20,
  max_topolow_iter = 1000, # Cutoff of one optimization
  topolow_opt_rounds = 1, # Optimization rounds for Topolow
  racmacs_opt_rounds = 200,  # Optimization rounds for RACMACS (You needs to do many optimizations and pick the best result)
  topolow_params = read.csv("optimal_parameters_250points.csv"),  # From parameter fitting
  use_slurm = FALSE,
  num_cores = 7
)

# Get absolute path for output directory
output_dir <- NULL
if (is.null(output_dir)) {
  output_dir <- file.path(getwd(), "synthetic_data")
}
output_dir <- normalizePath(output_dir, mustWork = FALSE)

# Create output directory if needed
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

# Create subdirectories
matrix_dir <- file.path(output_dir, "matrices")
topolow_results_dir <- file.path(output_dir, "topolow_results")
for (dir in c(matrix_dir, topolow_results_dir)) {
  if (!dir.exists(dir)) {
    dir.create(dir, recursive = TRUE)
  }
}
```

##Prepare Data and Cross-validation Folds

First, let's create synthetic datasets with different dimensionalities. We'll use synthetic distance matrices with different noise levels and missingness levels.

```{r}
# Generate datasets in 2, 5, and 10 dimensions
sim_data <- generate_synthetic_datasets(
  n_dims_list = c(2, 5, 10), 
  seeds = c(123450, 903450 , 13450), 
  n_points = 250,
  output_dir = "synthetic_data"
)

# Print dataset properties
print(sim_data$metadata)

# Get matrix variants to analyze
matrix_variants <- c("S_missing", "M_missing", "L_missing", "S_noise1", "M_noise1", "L_noise1", "S_noise_bias", "M_noise_bias", "L_noise_bias")
print("Matrix variants to analyze:")
print(matrix_variants)
```


## Find RACMACS optimal dimensions (semi-manual)
```{r}
#' Find Optimal Dimensionality for RACMACS with Early Stopping
#' 
#' Analyzes each simulated dataset with increasing dimensionality until coverage
#' falls below 95% or max dimension is reached.
#'
#' @param sim_data The sim_data from generate_synthetic_datasets 
#' @param matrix_variants Vector of matrix variant names to test
#' @param opt_setting List of optimization settings
#' @param output_dir Directory of the outputs
#' @return Data table with dimension results across all variants
find_optimal_racmacs_dimensions <- function(sim_data, matrix_variants, opt_setting, output_dir) {
  # Initialize results storage
  dim_results <- data.table(
    Dimension = integer(),
    MAE = numeric(),
    MAPE = numeric(),     # Added MAPE column
    Completeness = numeric(),
    OriginalDimension = integer(),
    Variant = character(),
    Algorithm = character(),
    stringsAsFactors = FALSE
  )
  
  # Create output directories if they don't exist
  racmacs_coords_dir <- file.path(output_dir, "racmacs_coordinates")  
  plots_dir <- file.path(output_dir, "plots")
  for (dir in c(racmacs_coords_dir, plots_dir)) {
    if (!dir.exists(dir)) {
      dir.create(dir, recursive = TRUE)
    }
  }
  
  # Maximum dimension to test before forcing early stop
  max_test_dimension <- 8
  
  # Process each original dataset dimension
  for(dim_idx in seq_along(sim_data$metadata$dimension)) {
    orig_dim <- sim_data$metadata$dimension[dim_idx]
    cat(sprintf("\nProcessing original %dD dataset\n", orig_dim))
    
    # Process each matrix variant
    for(variant in matrix_variants) {
      cat(sprintf("  Analyzing variant: %s\n", variant))
      
      # Get the distance matrix for this dimension and variant
      distance_matrix <- sim_data$matrices[[dim_idx]][[variant]]
      
      # Create CV folds
      matrix_list <- create_cv_folds(
        truth_matrix = distance_matrix,
        n_folds = opt_setting$n_folds
      )
      
      # Test dimensions starting from 2, incrementing until coverage < 95%
      continue_testing <- TRUE
      test_dim <- 2  # Start with 2D
      
      while(continue_testing && test_dim <= max_test_dimension) {
        cat(sprintf("    Testing dimension %d\n", test_dim))
        
        # Storage for this dimension's folds
        fold_mae <- numeric(opt_setting$n_folds)
        fold_mape <- numeric(opt_setting$n_folds)  # Added for MAPE
        fold_coverage <- numeric(opt_setting$n_folds)
        
        # Run each fold
        for(i in seq_len(opt_setting$n_folds)) {
          # Get matrices for this fold
          truth_matrix <- matrix_list[[i]][[1]]
          input_matrix <- matrix_list[[i]][[2]]
          
          # Convert to titer format
          titer_table <- dist_to_titer_table(input_matrix, base=exp(1), tens=1)
          
          # Create scenario name for this run
          scenario_name <- sprintf("dim%d_%s_fold%d", orig_dim, variant, i)
          
          # Run RACMACS optimization
          map <- create_and_optimize_RACMACS_map(
            titer_table = titer_table,
            dim = test_dim,
            optimization_number = opt_setting$racmacs_opt_rounds,
            num_cores = opt_params$num_cores,
            scenario_name = scenario_name
          )
          
          # Save coordinates
          coords_file <- file.path(racmacs_coords_dir, 
                                  paste0("RACMACS_", scenario_name, ".csv"))
          save.coords(map, filename = coords_file,
                     optimization_number = 1, antigens = TRUE, sera = TRUE)
          
          # Process RACMACS results
          positions_racmacs <- read.csv(coords_file)
          positions_racmacs$name <- ifelse(
            positions_racmacs$type == "antigen",
            paste0("V/", positions_racmacs$name),
            paste0("S/", positions_racmacs$name)
          )
          
          rownames(positions_racmacs) <- positions_racmacs$name
          positions_racmacs <- positions_racmacs[,3:ncol(positions_racmacs)]
          
          # Calculate distances
          p_dist_mat <- coordinates_to_matrix(as.matrix(positions_racmacs))
          
          # Calculate errors
          racmacs_errors <- error_calculator_comparison(
            p_dist_mat = p_dist_mat,
            truth_matrix = truth_matrix,
            input_matrix = input_matrix
          )
          
          # Store this fold's metrics
          fold_mae[i] <- mean(abs(racmacs_errors$report_df$OutSampleError), na.rm = TRUE)
          fold_mape[i] <- mean(abs(racmacs_errors$report_df$OutSamplePercentageError), na.rm = TRUE)  # Added MAPE calculation
          fold_coverage[i] <- racmacs_errors$coverage
        }
        
        # Calculate averages across folds
        mean_mae <- mean(fold_mae, na.rm = TRUE)
        mean_mape <- mean(fold_mape, na.rm = TRUE)  # Added MAPE average
        mean_coverage <- mean(fold_coverage, na.rm = TRUE)
        
        # Store dimension results
        dim_results <- rbind(
          dim_results,
          data.table(
            Dimension = test_dim,
            MAE = mean_mae,
            MAPE = mean_mape,  # Added MAPE to results
            Completeness = mean_coverage * 100,  # Convert to percentage
            OriginalDimension = orig_dim,
            Variant = variant,
            Algorithm = "MDS"
          )
        )
        
        # Check stopping condition - stop when coverage falls below 95%
        if(mean_coverage < 0.95) {
          cat(sprintf("    Completeness below 95%% (%.2f%%) - stopping dimension testing\n", 
                    mean_coverage * 100))
          continue_testing <- FALSE
        } else {
          test_dim <- test_dim + 1  # Test next dimension
        }
      }
    }
  }
  
  # Save dimension results
  results_file <- file.path(output_dir, "racmacs_dimensions_sim_data.csv")
  write.csv(dim_results, results_file, row.names = FALSE)
  cat(sprintf("\nResults saved to %s\n", results_file))
  
  return(dim_results)
}


#' Plot Individual Dimension Results for Each Dataset Variant
#'
#' @param results The dimension results dataframe
#' @param output_dir Directory to save 
#' @return The combined grid plot of all individual plots

plot_dimension_results <- function(results, output_dir) {
  plots_dir <- file.path(output_dir, "plots")
  if (!dir.exists(plots_dir)) {
    dir.create(plots_dir, recursive = TRUE)
  }
  
  # Get all unique combinations of original dimension and variant
  orig_dims <- sort(unique(results$OriginalDimension))
  variants <- sort(unique(results$Variant))
  
  # Create a list to store all individual plots
  individual_plots <- list()
  
  # Create plots for each combination
  for(orig_dim in orig_dims) {
    for(variant in variants) {
      # Get data for this specific dataset
      dataset_data <- results[results$OriginalDimension == orig_dim & 
                               results$Variant == variant, ]
      
      if(nrow(dataset_data) == 0) next
      
      # Calculate the scaled position for 95% coverage
      max_mae <- max(dataset_data$MAE)
      scaled_95_percent <- 95/max(dataset_data$Completeness)*max_mae
      
      # Create plot with dual y-axes for this dataset
      p <- ggplot(dataset_data, aes(x = Dimension)) +
        # MAE line
        geom_line(aes(y = MAE, color = "Validation MAE"), size = 0.8) +
        geom_point(aes(y = MAE, color = "Validation MAE"), size = 1.5) +
        # Completeness line (scaled to match MAE range for dual axis)
        geom_line(aes(y = Completeness/max(Completeness)*max_mae, color = "Completeness"), size = 0.8) +
        geom_point(aes(y = Completeness/max(Completeness)*max_mae, color = "Completeness"), size = 1.5) +
        # Add horizontal line at 95% coverage
        geom_hline(yintercept = scaled_95_percent, linetype = "dashed", color = "blue", alpha = 0.7) +
        # Set up axes
        scale_y_continuous(
          name = "Validation MAE",
          sec.axis = sec_axis(~ . * max(dataset_data$Completeness)/max_mae, name = "Completeness (%)")) +
        scale_color_manual(values = c("Validation MAE" = "red", "Completeness" = "blue"),
                         name = "Metric") +
        labs(x = "Dimension") +
        theme_minimal() +
        theme(
          panel.grid.minor = element_blank(),
          legend.position = "none",
          plot.title = element_text(size = 7, hjust = 0.5),
          axis.title = element_text(size = 6),
          axis.text = element_text(size = 6),
          plot.margin = margin(2, 2, 2, 2, "mm")
        )
      
      # Store the plot
      plot_key <- paste0("dim", orig_dim, "_", variant)
      individual_plots[[plot_key]] <- p
      
      # Save individual plot if needed
      individual_file <- file.path(plots_dir, paste0(plot_key, ".pdf"))
      ggsave(individual_file, p, width = 2.5, height = 2, units = "in")
    }
  }
  
  # Arrange all plots into a grid (dimensions as rows, variants as columns)
  # First, create a matrix of the plots in the right order
  plot_matrix <- matrix(list(), nrow = length(orig_dims), ncol = length(variants))
  rownames(plot_matrix) <- paste0(orig_dims, "D")
  colnames(plot_matrix) <- variants
  
  # Fill the matrix with plots
  for(i in seq_along(orig_dims)) {
    for(j in seq_along(variants)) {
      plot_key <- paste0("dim", orig_dims[i], "_", variants[j])
      if(plot_key %in% names(individual_plots)) {
        plot_matrix[i, j] <- individual_plots[[plot_key]]
      } else {
        # Create empty plot if this combination wasn't analyzed
        plot_matrix[i, j] <- list(ggplot() + theme_void())
      }
    }
  }
  
  # Create variant type labels for the top of the grid
  variant_types <- list(
    "Missing" = grep("missing", variants, value = TRUE),
    "Noise" = grep("noise1$", variants, value = TRUE),
    "Noise+Bias" = grep("noise_bias", variants, value = TRUE)
  )
  
  # Create plot titles with dimension and variant
  titles <- sapply(variants, function(v) {
    if(grepl("S_", v)) return("Low")
    if(grepl("M_", v)) return("Medium")
    if(grepl("L_", v)) return("High")
  })
  
  # Reorganize variants into proper order for grid
  # Define the variant order groups
  missing_variants <- grep("missing", variants, value = TRUE)
  noise_variants <- grep("noise1$", variants, value = TRUE)
  bias_variants <- grep("noise_bias", variants, value = TRUE)
  
  # Sort within each group by S, M, L
  sort_by_level <- function(vars) {
    vars[order(factor(gsub("_.*", "", vars), levels = c("S", "M", "L")))]
  }
  
  missing_variants <- sort_by_level(missing_variants)
  noise_variants <- sort_by_level(noise_variants)
  bias_variants <- sort_by_level(bias_variants)
  
  # Combine in the desired order
  ordered_variants <- c(missing_variants, noise_variants, bias_variants)
  
  # Create a vector of column spans for the top annotation
  col_spans <- c(length(missing_variants), length(noise_variants), length(bias_variants))
  top_labels <- c("Missing Data", "Noise", "Noise+Bias")
  
  # Convert plot matrix to a list in column-major order for arranging
  plot_list <- list()
  title_list <- list()
  
  for(v in ordered_variants) {
    for(d in orig_dims) {
      plot_key <- paste0("dim", d, "_", v)
      if(plot_key %in% names(individual_plots)) {
        plot_list <- c(plot_list, individual_plots[[plot_key]])
        
        # Determine level from variant
        level <- if(grepl("S_", v)) "Low" else if(grepl("M_", v)) "Medium" else "High"
        title_list <- c(title_list, level)
      }
    }
  }
  
  # Create the combined grid plot
  # First arrange the plots in a grid
  combined_plot <- grid.arrange(
    grobs = plot_list,
    ncol = length(ordered_variants),
    nrow = length(orig_dims),
    top = textGrob("RACMACS Dimensionality Analysis", gp = gpar(fontsize = 10, fontface = "bold")),
    left = textGrob("Original Dimension", rot = 90, gp = gpar(fontsize = 8)),
    bottom = textGrob("Test Dimension", gp = gpar(fontsize = 8)),
    heights = unit(rep(1, length(orig_dims)), "null"),
    widths = unit(rep(1, length(ordered_variants)), "null")
  )
  
  # Save the combined plot
  combined_file <- file.path(plots_dir, "all_dimension_analysis.pdf")
  ggsave(combined_file, combined_plot, width = 9, height = 4, units = "in")
  
  # Create a nicer version with proper labels using ggplot
  # Prepare data for faceted plot
  plot_data <- results %>%
    # Extract data severity level (S/M/L)
    mutate(
      Level = case_when(
        grepl("^S_", Variant) ~ "Low",
        grepl("^M_", Variant) ~ "Medium",
        grepl("^L_", Variant) ~ "High"
      ),
      # Extract variant type
      VariantType = case_when(
        grepl("missing", Variant) ~ "Missing Data",
        grepl("noise_bias", Variant) ~ "Noise+Bias",
        grepl("noise1", Variant) ~ "Noise"
      )
    ) %>%
    # Add dimension label for faceting
    mutate(DimensionLabel = paste0(OriginalDimension, "D"))
  
  # Ensure proper ordering
  plot_data$Level <- factor(plot_data$Level, levels = c("Low", "Medium", "High"))
  plot_data$VariantType <- factor(plot_data$VariantType, 
                                 levels = c("Missing Data", "Noise", "Noise+Bias"))
  plot_data$DimensionLabel <- factor(plot_data$DimensionLabel,
                                    levels = paste0(orig_dims, "D"))
  
  # Create a legend plot for the metrics
  legend_data <- data.frame(
    x = 1:2,
    y = 1:2,
    Metric = c("Validation MAE", "Completeness")
  )
  legend_plot <- ggplot(legend_data, aes(x = x, y = y, color = Metric)) +
    geom_point() +
    scale_color_manual(values = c("Validation MAE" = "red", "Completeness" = "blue")) +
    theme_void() +
    theme(legend.position = "bottom")
  legend <- get_legend(legend_plot)
  
  # Create faceted plot for the grid
  facet_plot <- ggplot(plot_data) +
    # Create one panel per dimension x variant type x level
    facet_grid(
      DimensionLabel ~ VariantType + Level,
      scales = "free_y",
      switch = "y"
    ) +
    # MAE line
    geom_line(aes(x = Dimension, y = MAE, color = "Validation MAE"), size = 0.6) +
    geom_point(aes(x = Dimension, y = MAE, color = "Validation MAE"), size = 1.2) +
    # Completeness line with secondary y-axis scaling done in annotation
    geom_line(aes(x = Dimension, y = Completeness/100*max(MAE), color = "Completeness"), size = 0.6) +
    geom_point(aes(x = Dimension, y = Completeness/100*max(MAE), color = "Completeness"), size = 1.2) +
    # 95% coverage reference line
    geom_hline(aes(yintercept = 0.95*max(MAE)), linetype = "dashed", color = "blue", alpha = 0.4) +
    # Styling
    scale_color_manual(values = c("Validation MAE" = "red", "Completeness" = "blue")) +
    labs(
      x = "Test Dimension",
      y = "Validation MAE"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(size = 7, face = "bold"),
      strip.background = element_rect(fill = "gray95", color = NA),
      axis.title = element_text(size = 8),
      axis.text = element_text(size = 6),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_line(color = "gray90", size = 0.2),
      legend.position = "none",
      panel.spacing = unit(1, "mm")
    )
  
  # Save the faceted grid plot
  facet_file <- file.path(plots_dir, "faceted_dimension_analysis.pdf")
  facet_plot_with_legend <- grid.arrange(facet_plot, legend, nrow = 2, 
                                        heights = unit(c(4, 0.3), "in"))
  ggsave(facet_file, facet_plot_with_legend, width = 9, height = 4.5, units = "in")
  
  # Return both plot types
  return(list(
    individual_plots = individual_plots,
    combined_plot = combined_plot,
    faceted_plot = facet_plot_with_legend
  ))
}
```

```{r}
# script to run RACMACS dimensionality analysis with early stopping

# Run the analysis
dim_results <- find_optimal_racmacs_dimensions(
  sim_data = sim_data,  # The sim_data from generate_synthetic_datasets 
  matrix_variants = matrix_variants,  # From the input setup
  opt_setting = opt_params,  # From the input setup 
  output_dir = output_dir  # From the input setup
)

```

```{r}
# Generate plots
dim_results <- read.csv("racmacs_dimensions_sim_data.csv")

all_plots <- plot_dimension_results(dim_results, output_dir)

# Output a summary of findings
cat("\n----- Summary of Optimal Dimensions -----\n")
# Group by original dimension and variant, find where coverage drops below 95%
summary_table <- dim_results %>%
  group_by(OriginalDimension, Variant) %>%
  arrange(OriginalDimension, Variant, Dimension) %>%
  filter(Completeness < 95) %>%
  slice(1) %>%
  mutate(LastGoodDimension = Dimension - 1) %>%
  select(OriginalDimension, Variant, LastGoodDimension, Completeness) %>%
  arrange(OriginalDimension, Variant)

print(summary_table)
```


##Setup Result Collection:

Initialize data structures to collect performance metrics.
We run RACMACS in 2D and in the same dim as Topolow (the optimal dimensionality found by Topolow)

```{r}
# Initialize Topolow results dataframes
topolow_errors_df <- data.table(
  InSampleError = numeric(),
  OutSampleError = numeric(),
  InSamplePercentageError = numeric(),
  OutSamplePercentageError = numeric(),
  Dimension = numeric(),
  Algorithm = character(),
  Scenario = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

topolow_mapped_objects_df <- data.table(
  Dimension = numeric(),
  Mapped = numeric(),
  Total = numeric(),
  Validation_Coverage = numeric(),
  Algorithm = character(),
  Scenario = character(), 
  Fold = numeric(),
  stringsAsFactors = FALSE
)

topolow_cor_df <- data.table(
  Dimension = numeric(),
  Validation_Cor = numeric(),
  Algorithm = character(),
  Scenario = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

# Initialize racmacs results tables

racmacs_2D_errors_df <- data.table(
  InSampleError = numeric(),
  OutSampleError = numeric(), 
  InSamplePercentageError = numeric(),
  OutSamplePercentageError = numeric(),
  Dimension = numeric(),
  Algorithm = character(),
  Scenario = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

racmacs_TrueDim_errors_df <- data.table(
  InSampleError = numeric(),
  OutSampleError = numeric(), 
  InSamplePercentageError = numeric(),
  OutSamplePercentageError = numeric(),
  Dimension = numeric(),
  Algorithm = character(),
  Scenario = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

racmacs_2D_coverage <- data.table(
  Dimension = numeric(),
  Mapped = numeric(),
  Total = numeric(), 
  Validation_Coverage = numeric(),
  Algorithm = character(),
  Scenario = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

racmacs_TrueDim_coverage <- data.table(
  Dimension = numeric(),
  Mapped = numeric(),
  Total = numeric(), 
  Validation_Coverage = numeric(),
  Algorithm = character(),
  Scenario = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

racmacs_2D_cor_df <- data.table(
  Dimension = numeric(),
  Validation_Cor = numeric(),  
  Algorithm = character(),
  Scenario = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)

racmacs_TrueDim_cor_df <- data.table(
  Dimension = numeric(),
  Validation_Cor = numeric(),  
  Algorithm = character(),
  Scenario = character(),
  Fold = numeric(),
  stringsAsFactors = FALSE
)
```


## Run Comparison

Now we'll run both algorithms for each fold:

```{r eval=FALSE}
cc=0 # scenario counter
# Process each dimension
for (ndim in sim_data$metadata$dimension) {
  dim_data <- sim_data$matrices[[which(sim_data$metadata$dimension == ndim)]]
  
  # Process each matrix variant
  for (matrix_type in matrix_variants) {
    cc = cc+1
    scenario_name <- sprintf("dim%d_%s", ndim, matrix_type)
    
    # Get optimal parameters for this scenario
    best_params <- opt_params$topolow_params %>%
      filter(true_dim == ndim, matrix_type == !!matrix_type)
    
    if (nrow(best_params) == 0) {
      warning("No optimal parameters found for scenario: ", scenario_name)
      next
    }
    
    # Convert parameters to expected format
    best_params <- list(
      N = round(exp(best_params$log_N)),
      k0 = exp(best_params$log_k0),
      cooling_rate = exp(best_params$log_cooling_rate),
      c_repulsion = exp(best_params$log_c_repulsion)
    )
    
    # Get truth matrix and corresponding no-noise truth if needed
    truth_matrix <- dim_data[[matrix_type]]
    no_noise_truth <- if(grepl("noise|bias", matrix_type)) {
      dim_data[[sub("_noise.*|_bias.*", "_missing", matrix_type)]]
    } else {
      NULL
    }
    
    # Create CV folds 
    matrix_list <- create_cv_folds(
      truth_matrix = truth_matrix,
      no_noise_truth = no_noise_truth,
      n_folds = opt_params$n_folds,
    )
    
    # Save matrix list for SLURM jobs
    if (opt_params$use_slurm) {
      matrix_file <- file.path(matrix_dir,
                               sprintf("%s_matrices.rds", scenario_name))
      saveRDS(matrix_list, matrix_file)
    }
    
    # Run comparison for each fold
    for(i in seq_len(opt_params$n_folds)) {
      
      
      
      #           ##################Topolow#####################


      if (opt_params$use_slurm) {
        # Submit Topolow job to SLURM
        args_list <- c(
          normalizePath(matrix_file),
          as.character(best_params$N),
          as.character(opt_params$max_topolow_iter),
          as.character(best_params$k0),
          as.character(best_params$cooling_rate),
          as.character(best_params$c_repulsion),
          scenario_name,
          as.character(i),
          as.character(topolow_results_dir)
        )

        slurm_script <- create_slurm_script(
          job_name = sprintf("%d_comparison_topolow_%s", i, scenario_name),
          script_path = system.file("scripts/run_topolow_comparison.R",
                                    package = "topolow"),
          args = args_list,
          num_cores = 1,
          time = "8:00:00",
          memory = "18G",
          output_file = file.path(topolow_results_dir,
                                  sprintf("%s_fold%d.out", scenario_name, i)),
          error_file = file.path(topolow_results_dir,
                                 sprintf("%s_fold%d.err", scenario_name, i))
        )

        submit_job(slurm_script, use_slurm = opt_params$use_slurm,
                   cider = TRUE)
      } else{
        cat(sprintf("Scenario %d out of %d \n", cc, length(sim_data$metadata$dimension)*length(matrix_variants)))
        # Run Topolow locally and collect results in same format as RACMACS
        truth_matrix <- matrix_list[[i]][[1]]
        input_matrix <- matrix_list[[i]][[2]]

        # Run Topolow optimization
        result <- create_topolow_map(
          distance_matrix = input_matrix,
          ndim = best_params$N,
          mapping_max_iter = opt_params$max_topolow_iter,
          k0 = best_params$k0,
          cooling_rate = best_params$cooling_rate,
          c_repulsion = best_params$c_repulsion,
          write_positions_to_csv = FALSE,
          verbose = TRUE
        )

        p_dist_mat <- result$est_distances

        # Calculate performance metrics
        topolow_errors <- error_calculator_comparison(
          p_dist_mat = p_dist_mat,
          truth_matrix = truth_matrix,
          input_matrix = input_matrix
        )

        # Store error results
        topolow_df <- topolow_errors$report_df
        topolow_df$Dimension <- best_params$N
        topolow_df$Algorithm <- "Topolow"
        topolow_df$Scenario <- scenario_name
        topolow_df$Fold <- i
        topolow_errors_df <- rbind(topolow_errors_df, topolow_df)

        # Store coverage results
        topolow_mapped_objects_df <- rbind(
          topolow_mapped_objects_df,
          data.table(
            Dimension = best_params$N,
            Mapped = nrow(p_dist_mat),
            Total = nrow(truth_matrix),
            Validation_Coverage = topolow_errors$coverage,
            Algorithm = "Topolow",
            Scenario = scenario_name,
            Fold = i
          )
        )

        # Store correlation results
        topolow_cor_df <- rbind(
          topolow_cor_df,
          data.table(
            Dimension = best_params$N,
            Validation_Cor = topolow_errors$OutSampleCor,
            Algorithm = "Topolow",
            Scenario = scenario_name,
            Fold = i
          )
        )
      }
      
      
                #################RACMACS 2D ######################
      
      cat(sprintf("Scenario %d out of %d \n", cc, length(sim_data$metadata$dimension)*length(matrix_variants)))

      # Run RACMACS locally
      truth_matrix <- matrix_list[[i]][[1]]
      input_matrix <- matrix_list[[i]][[2]]

      # Convert to titer format for RACMACS
      titer_table <- dist_to_titer_table(input_matrix, base=2, tens=10)

      # Run RACMACS optimization
      map <- create_and_optimize_RACMACS_map(
        titer_table = titer_table,
        dim = 2,
        optimization_number = opt_params$racmacs_opt_rounds,
        num_cores = opt_params$num_cores,
        scenario_name = scenario_name
      )

      save.coords(map, filename = "RACMACS_coords.csv",
                 optimization_number = 1, antigens = TRUE, sera = TRUE)

      # Process RACMACS results
      positions_racmacs <- read.csv("RACMACS_coords.csv")
      #positions_racmacs <- na.omit(positions_racmacs)
      count_mapped_rows <- positions_racmacs %>%
        filter(rowSums(is.na(.)) == 0) %>%
        nrow()

      positions_racmacs <- positions_racmacs %>%
        mutate(name = case_when(
          type == "antigen" ~ paste0("V/", name),
          type == "sera" ~ paste0("S/", name),
          TRUE ~ name
        ))

      rownames(positions_racmacs) <- positions_racmacs$name
      positions_racmacs <- positions_racmacs[,3:ncol(positions_racmacs)]

      # Calculate performance metrics
      p_dist_mat <- coordinates_to_matrix(as.matrix(positions_racmacs))

      racmacs_errors <- error_calculator_comparison(
        p_dist_mat = p_dist_mat,
        truth_matrix = truth_matrix,
        input_matrix = input_matrix
      )

      # Store results
      racmacs_df <- racmacs_errors$report_df
      racmacs_df$Dimension = ndim
      racmacs_df$Algorithm = "MDS"
      racmacs_df$Scenario = scenario_name
      racmacs_df$Fold <- i
      racmacs_2D_errors_df <- rbind(racmacs_2D_errors_df, racmacs_df)

      racmacs_2D_coverage <- rbind(
        racmacs_2D_coverage,
        data.table(
          Dimension = ndim,
          Mapped = count_mapped_rows,
          Total = nrow(truth_matrix),
          Validation_Coverage = racmacs_errors$coverage,
          Algorithm = "MDS",
          Scenario = scenario_name,
          Fold = i
        )
      )

      racmacs_2D_cor_df <- rbind(
        racmacs_2D_cor_df,
        data.table(
          Dimension = ndim,
          Validation_Cor = racmacs_errors$OutSampleCor,
          Algorithm = "MDS",
          Scenario = scenario_name,
          Fold = i
        )
      )
      
      
      
      #           #################RACMACS True Dim######################
      # 
      # 
      # # Run RACMACS optimization
      # map <- create_and_optimize_RACMACS_map(
      #   titer_table = titer_table,
      #   dim = best_params$N,
      #   optimization_number = opt_params$racmacs_opt_rounds,
      #   num_cores = opt_params$num_cores,
      #   scenario_name = scenario_name
      # )
      # 
      # save.coords(map, filename = "RACMACS_coords.csv",
      #            optimization_number = 1, antigens = TRUE, sera = TRUE)
      # 
      # # Process RACMACS results
      # positions_racmacs <- read.csv("RACMACS_coords.csv")
      # #positions_racmacs <- na.omit(positions_racmacs)
      # count_mapped_rows <- positions_racmacs %>%
      #   filter(rowSums(is.na(.)) == 0) %>%
      #   nrow()
      # 
      # positions_racmacs <- positions_racmacs %>%
      #   mutate(name = case_when(
      #     type == "antigen" ~ paste0("V/", name),
      #     type == "sera" ~ paste0("S/", name),
      #     TRUE ~ name
      #   ))
      # 
      # rownames(positions_racmacs) <- positions_racmacs$name
      # positions_racmacs <- positions_racmacs[,3:ncol(positions_racmacs)]
      # 
      # # Calculate performance metrics
      # p_dist_mat <- coordinates_to_matrix(as.matrix(positions_racmacs))
      # 
      # racmacs_errors <- error_calculator_comparison(
      #   p_dist_mat = p_dist_mat,
      #   truth_matrix = truth_matrix,
      #   input_matrix = input_matrix
      # )
      # 
      # # Store results
      # racmacs_df <- racmacs_errors$report_df
      # racmacs_df$Dimension = ndim
      # racmacs_df$Algorithm = "MDS"
      # racmacs_df$Scenario = scenario_name
      # racmacs_df$Fold <- i
      # racmacs_TrueDim_errors_df <- rbind(racmacs_TrueDim_errors_df, racmacs_df)
      # 
      # racmacs_TrueDim_coverage <- rbind(
      #   racmacs_TrueDim_coverage,
      #   data.table(
      #     Dimension = ndim,
      #     Mapped = count_mapped_rows,
      #     Total = nrow(truth_matrix),
      #     Validation_Coverage = racmacs_errors$coverage,
      #     Algorithm = "MDS",
      #     Scenario = scenario_name,
      #     Fold = i
      #   )
      # )
      # 
      # racmacs_TrueDim_cor_df <- rbind(
      #   racmacs_TrueDim_cor_df,
      #   data.table(
      #     Dimension = ndim,
      #     Validation_Cor = racmacs_errors$OutSampleCor,
      #     Algorithm = "MDS",
      #     Scenario = scenario_name,
      #     Fold = i
      #   )
      # )
      
    }
  }
}

# Save results
write.csv(topolow_errors_df,"Topolow_comparisondf.csv",
          row.names = FALSE)

write.csv(topolow_mapped_objects_df, "Topolow_mapped_objects.csv",
          row.names = FALSE)

write.csv(topolow_cor_df, "Topolow_cor.csv",
          row.names = FALSE)

write.csv(racmacs_2D_errors_df,"RACMACS_comparisondf.csv",
          row.names = FALSE)

write.csv(racmacs_2D_coverage, "RACMACS_mapped_objects.csv",
          row.names = FALSE)

write.csv(racmacs_2D_cor_df, "RACMACS_cor.csv",
          row.names = FALSE)

# write.csv(racmacs_TrueDim_errors_df,"RACMACS_TrueDim_comparisondf.csv",
#           row.names = FALSE)
# 
# write.csv(racmacs_TrueDim_coverage, "RACMACS_TrueDim_mapped_objects.csv",
#           row.names = FALSE)
# 
# write.csv(racmacs_TrueDim_cor_df, "RACMACS_TrueDim_cor.csv",
#           row.names = FALSE)
```


##Collect and Aggregate Results

After all Topolow jobs complete, collect and analyze results:

```{r}
# Read the CSV files back into dataframes
racmacs_2D_errors_df <- read.csv("RACMACS_comparisondf.csv")
racmacs_2D_coverage <- read.csv("RACMACS_mapped_objects.csv")
racmacs_2D_cor_df <- read.csv("RACMACS_cor.csv")

#racmacs_TrueDim_coverage <- read.csv("RACMACS_TrueDim_mapped_objects.csv")

topolow_errors_df <- read.csv("Topolow_comparisondf.csv")
topolow_mapped_objects_df <- read.csv("Topolow_mapped_objects.csv")
topolow_cor_df <- read.csv("Topolow_cor.csv")
```

```{r}
## If SLURM was used:
# Collect Topolow results from SLURM output


# directory_path <- "results"
# 
# # Errors
# pattern <- paste0("_errors", "\\.csv$")
# csv_files <- list.files(path = directory_path, pattern = pattern, 
#                        full.names = TRUE)
# topolow_errors_df <- rbindlist(lapply(csv_files, fread), 
#                            use.names = TRUE, fill = TRUE)
# 
# # Completeness
# pattern <- paste0("_coverage", "\\.csv$")
# csv_files <- list.files(path = directory_path, pattern = pattern,
#                        full.names = TRUE)
# topolow_mapped_objects_df <- rbindlist(lapply(csv_files, fread),
#                                      use.names = TRUE, fill = TRUE)
# 
# # Correlation
# pattern <- paste0("_cor", "\\.csv$")
# csv_files <- list.files(path = directory_path, pattern = pattern,
#                        full.names = TRUE)
# topolow_cor_df <- rbindlist(lapply(csv_files, fread),
#                           use.names = TRUE, fill = TRUE)
```


##Analyze Results

Calculate summary statistics for both algorithms:

```{r}
# Calculate MAE and SD across folds
get_scenario_stats <- function(errors, metric) {
  fold_stats <- aggregate(
    as.formula(paste(metric, "~ Scenario + Fold")),
    data = errors,
    FUN = function(x) mean(abs(x), na.rm = TRUE) 
  ) 
  scenario_stats <- aggregate(
    as.formula(paste(metric, "~ Scenario")),
    data = fold_stats,
    FUN = function(x) c(mean = mean(x, na.rm = TRUE), sd = sd(x, na.rm = TRUE))
  )

  # Split the combined mean and sd into separate columns
  scenario_stats <- do.call(data.frame, scenario_stats)
  colnames(scenario_stats)[2:3] <- c("Mean", "SD")
  
  return(scenario_stats)
}

# RACMACS results
racmacs_mae_stats <- get_scenario_stats(racmacs_2D_errors_df, metric = "OutSampleError")
racmacs_mape_stats <- get_scenario_stats(racmacs_2D_errors_df, metric = "OutSamplePercentageError")
racmacs_cor_stats <- get_scenario_stats(racmacs_2D_cor_df, metric = "Validation_Cor")
racmacs_2D_coverage_stats <- get_scenario_stats(racmacs_2D_coverage, metric = "Mapped")
#racmacs_TrueDim_coverage_stats <- get_scenario_stats(racmacs_TrueDim_coverage, metric = "Mapped")

# Topolow results  
topolow_mae_stats <- get_scenario_stats(topolow_errors_df, metric = "OutSampleError")
topolow_mape_stats <- get_scenario_stats(topolow_errors_df, metric = "OutSamplePercentageError")
topolow_cor_stats <- get_scenario_stats(topolow_cor_df, metric = "Validation_Cor")
topolow_coverage_stats <- get_scenario_stats(topolow_mapped_objects_df, metric = "Mapped")

# Add the new columns
add_columns <- function(df, Method) {
  df <- df %>%
    mutate(
      Dimension = as.numeric(sub("dim(\\d+)_.*", "\\1", Scenario)),
      Missing = case_when(
        grepl("_S_", Scenario) ~ "70%",
        grepl("_M_", Scenario) ~ "85%",
        grepl("_L_", Scenario) ~ "95%"
      ),
      Variant = case_when(
        grepl("_missing$", Scenario) ~ "Original",
        grepl("_noise1$", Scenario) ~ "+Noise",
        grepl("_noise_bias$", Scenario) ~ "+Noise+Bias"
      ),
      Method = Method
    )
  return(df)
}

racmacs_mae_stats <- add_columns(racmacs_mae_stats, Method="MDS")
racmacs_mape_stats <- add_columns(racmacs_mape_stats, Method="MDS")
racmacs_cor_stats <- add_columns(racmacs_cor_stats, Method="MDS")
racmacs_2D_coverage_stats <- add_columns(racmacs_2D_coverage_stats, Method="MDS")
#racmacs_TrueDim_coverage_stats <- add_columns(racmacs_TrueDim_coverage_stats, Method="MDS")

topolow_mae_stats <- add_columns(topolow_mae_stats, Method="Topolow")
topolow_cor_stats <- add_columns(topolow_cor_stats, Method="Topolow")
topolow_coverage_stats <- add_columns(topolow_coverage_stats, Method="Topolow")
topolow_mape_stats <- add_columns(topolow_mape_stats, Method="Topolow")
```


##Visualization

```{r}
all_mape_results <- rbind(topolow_mape_stats, racmacs_mape_stats)
all_mape_results <- all_mape_results %>% dplyr::mutate(MAPE=Mean)
all_mape_results$Variant <- factor(all_mape_results$Variant, 
                                 levels = c("Original", "+Noise", "+Noise+Bias"))

# Create MAPE plot
p <- ggplot(all_mape_results, aes(x = Missing, y = MAPE, fill = Method)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = MAPE - SD, ymax = MAPE + SD),
                position = position_dodge(width = 0.9), width = 0.25) +
  facet_grid(Dimension ~ Variant) +
  scale_fill_manual(values = c("Topolow" = "#4dbedf", "MDS" = "#e59572")) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 6),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_text(size = 6),
    strip.text = element_text(size = 6, face = "bold"),
    strip.background = element_rect(fill = "gray95"),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6),
    legend.key.size = unit(0.8, "lines"),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  ) +
  labs(
    x = "Missing Data Level",
    y = "Validation Mean Absolute Percentage Error (±SD)"
  )

# Save plot
ggsave("Method_comparison_MAPE_plot_250points.pdf", plot = p, width = 172, height = 0.5*172, units = "mm", dpi = 300)

print(p)
```


```{r}
all_mae_results <- rbind(topolow_mae_stats, racmacs_mae_stats)
all_mae_results <- all_mae_results %>% dplyr::mutate(MAE=Mean)

all_mae_results$Variant <- factor(all_mae_results$Variant, 
                                  levels = c("Original", "+Noise", "+Noise+Bias"))

p <- ggplot(all_mae_results, aes(x = Missing, y = MAE, fill = Method)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = MAE - SD, ymax = MAE + SD),
                position = position_dodge(width = 0.9), width = 0.25) +
  facet_grid(Dimension ~ Variant) +
  scale_fill_manual(values = c("Topolow" = "#4dbedf", "MDS" = "#e59572")) +
  theme_minimal() +
  theme(
    # Axis text
    axis.title = element_text(size = 6),
    axis.text.x = element_text(size = 5), #, angle = 45, hjust = 1
    axis.text.y = element_text(size = 5),
    
    # Panel labels and strips
    strip.text = element_text(size = 6, face = "bold"),
    strip.background = element_rect(fill = "gray95"),
    
    # Legend
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 5),
    legend.key.size = unit(0.8, "lines"),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  ) +
  labs(
    x = "Missing Data Level",
    y = "Mean Absolute Error (±SD)"
  )

# Save with adjusted dimensions to accommodate smaller text
ggsave("Method_comparison_MAE_plot_250points.pdf", plot = p, width = 172, height = 0.5*172, units = "mm", dpi = 300)

print(p)
```


## Summary table

```{r}
# Create summary table
summary_table <- all_mape_results %>%
  mutate(
    MAPE_SD = sprintf("%.3f ± %.3f", MAPE, SD)
  ) %>%
  select(Dimension, Missing, Variant, Method, MAPE_SD) %>%
  spread(Method, MAPE_SD)

# Create and save the LaTeX table
latex_table <- knitr::kable(summary_table, 
                           caption = "Performance across complexity and missingness levels (MAPE +- SD). Supporting information for Figure ",
                           format = "latex",
                           booktabs = TRUE,
                           align = rep('c', ncol(summary_table)))

# Print the LaTeX code
cat(latex_table)
```


```{r}
all_coverage_results <- bind_rows(topolow_coverage_stats, racmacs_2D_coverage_stats)

# Create summary table of coverage
summary_table_cov <- all_coverage_results %>%
  group_by(Dimension, Missing, Method) %>%
  summarize(Mean = mean(Mean), .groups = 'drop') %>%
  spread(Method, Mean)

summary_table_cov$MDS <- round(summary_table_cov$MDS)
# Create and save LaTeX table to a variable
latex_table <- knitr::kable(summary_table_cov,
                           caption = "Count of mapped antigens/antisera",
                           format = "latex",
                           booktabs = TRUE,
                           align = rep('c', ncol(summary_table_cov)))

# To view the table (optional)
cat(latex_table)
```


### Statistical Analysis

```{r}
# Calculate MAE and SD across folds
get_fold_stats <- function(errors, metric) {
  fold_stats <- aggregate(
    as.formula(paste(metric, "~ Scenario + Fold")),
    data = errors,
    FUN = function(x) mean(abs(x), na.rm = TRUE) 
  ) 

  # Split the combined mean and sd into separate columns
  fold_stats <- do.call(data.frame, fold_stats)
  colnames(fold_stats)[3] <- c("MAPE")
  
  return(fold_stats)
}


# RACMACS results
racmacs_ttest <- get_fold_stats(racmacs_2D_errors_df, metric = "OutSamplePercentageError")
racmacs_ttest$Method <- "MDS"

# Topolow results  
topolow_ttest <- get_fold_stats(topolow_errors_df, metric = "OutSamplePercentageError")
topolow_ttest$Method <- "Topolow"

# Aggregate and add necessary columns
all_ttest <- rbind(racmacs_ttest, topolow_ttest)
all_ttest <- add_columns(all_ttest)

# Perform paired t-tests for each condition
stat_tests <- all_ttest %>%
  group_by(Dimension, Missing, Variant) %>%
  summarize(
    t_stat = t.test(MAPE[Method == "MDS"],
                    MAPE[Method == "Topolow"],
                    paired = TRUE)$statistic,
    p_value = t.test(MAPE[Method == "MDS"],
                     MAPE[Method == "Topolow"],
                     paired = TRUE)$p.value,
    .groups = 'drop'
  ) %>%
  mutate(
    #significant = p_value < 0.05,
    Sig.Level = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**", 
      p_value < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  )


# Create and save LaTeX table to a variable
latex_table <- knitr::kable(stat_tests,
                            caption = "Statistical Significance Tests",
                           format = "latex",
                           booktabs = TRUE,
                           align = rep('c', ncol(stat_tests)))

# To view the table (optional)
cat(latex_table)
```

### Distribution of errors

```{r}
# Calculate MAE and SD across folds
get_scenario_distribution <- function(errors, metric) {
  scenario_stats <- aggregate(
    as.formula(paste(metric, "~ Scenario")),
    data = errors,
    FUN = function(x) c(mean(x, na.rm = TRUE), sd = sd(x, na.rm = TRUE)) 
  ) 

  # Split the combined mean and sd into separate columns
  scenario_stats <- do.call(data.frame, scenario_stats)
  colnames(scenario_stats)[2:3] <- c("MAE", "SD")
  
  return(scenario_stats)
}

racmacs_e_stats <- get_scenario_distribution(racmacs_2D_errors_df, metric = "OutSampleError")
topolow_e_stats <- get_scenario_distribution(topolow_errors_df, metric = "OutSampleError")

racmacs_e_stats <- add_columns(racmacs_e_stats, Method="MDS")
topolow_e_stats <- add_columns(topolow_e_stats, Method="Topolow")

all_e_stats <- rbind(racmacs_e_stats, topolow_e_stats)

# Create summary table
summary_table <- all_e_stats %>%
  mutate(
    ME_SD = sprintf("%.3f ± %.3f", MAE, SD)
  ) %>%
  select(Dimension, Missing, Variant, Method, ME_SD) %>%
  spread(Method, ME_SD)

# Create and save LaTeX table to a variable
latex_table <- knitr::kable(summary_table,
                            caption = "Distribution of errors (Mean ± SD)",
                           format = "latex",
                           booktabs = TRUE,
                           align = rep('c', ncol(summary_table)))

# To view the table (optional)
cat(latex_table)
```

### Error reduction in noisy inputs

```{r}
# Calculate error reduction analysis
error_reduction_analysis <- function(ndim, scenario_variant, method_errors, results) {
  # Construct full scenario name
  scenario_name <- sprintf("dim%d_%s", ndim, scenario_variant)
  
  # Get corresponding matrices
  noisy_matrix <- results$matrices[[which(results$metadata$dimension == ndim)]][[scenario_variant]]
  missing_matrix_name <- sub("_noise.*|_bias.*", "_missing", scenario_variant)
  missing_matrix <- results$matrices[[which(results$metadata$dimension == ndim)]][[missing_matrix_name]]
  
  # Calculate mean difference between matrices
  noisy_input_MAPE <- 100*mean(abs((noisy_matrix - missing_matrix)/missing_matrix), na.rm = TRUE)
  
  # Calculate mean Topolow error for this scenario
  method_errors <- method_errors[method_errors$Scenario == scenario_name,]
  method_MAPE <- mean(abs(ifelse(is.na(method_errors$InSamplePercentageError), 
                           method_errors$OutSamplePercentageError,
                           method_errors$InSamplePercentageError)), 
                    na.rm = TRUE)
  
  return(c(noisy_input_MAPE = noisy_input_MAPE, method_MAPE = method_MAPE))
}

# Get scenarios to analyze
noise_variants <- c("S_noise1", "S_noise_bias", "M_noise1", "M_noise_bias", 
                   "L_noise1", "L_noise_bias")

# Initialize results dataframe
error_reduction <- data.frame(
  Dimension = numeric(),
  Scenario = character(),
  noisy_input_Error = numeric(),
  Topolow_Error = numeric(),
  MDS_Error = numeric(),
  stringsAsFactors = FALSE
)

# Calculate error reduction for each dimension and scenario
for (ndim in sim_data$metadata$dimension) {
  for (variant in noise_variants) {
    topo <- error_reduction_analysis(ndim, variant, topolow_errors_df, sim_data)
    mds <- error_reduction_analysis(ndim, variant, racmacs_2D_errors_df, sim_data)
    error_reduction <- rbind(error_reduction, 
                          data.frame(
                            Dimension = ndim,
                            Scenario = variant,
                            noisy_input_Error = topo["noisy_input_MAPE"],
                            Topolow_Error = topo["method_MAPE"],
                            MDS_Error = mds["method_MAPE"]))
  }
}

# Add descriptive columns
error_reduction <- error_reduction %>%
  mutate(
    Missing = case_when(
      grepl("^S_", Scenario) ~ "70%",
      grepl("^M_", Scenario) ~ "85%", 
      grepl("^L_", Scenario) ~ "95%"
    ),
    Variant = ifelse(grepl("_noise1$", Scenario), "+Noise", "+Noise+Bias")
  ) %>%
  select(Dimension, Missing, Variant, noisy_input_Error, MDS_Error, Topolow_Error)

names(error_reduction)[4:6] <- c("Input", "MDS", "Topolow")
rownames(error_reduction) <- NULL


# Create and save LaTeX table to a variable
latex_table <- knitr::kable(error_reduction,
                           caption = "Error Reduction Analysis",
                           digits = 3,
                           format = "latex",
                           booktabs = TRUE,
                           align = rep('l', ncol(error_reduction)))

# To view the table (optional)
cat(latex_table)
```


## Antigenic maps

```{r}
# Create visualization configurations
dim_config <- new_dim_reduction_config(
  method = "pca",
  n_components = 2,
  scale = FALSE
)

aesthetic_config <- new_aesthetic_config(
  point_shapes = c(antigen = 16, antiserum = 4),
  point_size = 1.9,
  point_alpha = 0.65,
  color_palette = P60,
  gradient_colors = list(low = "blue", high = "red"),
  title_size = 8,
  subtitle_size = 7,
  axis_title_size = 7,
  axis_text_size = 6,
  legend_text_size =  7,
  legend_title_size = 7,
  show_legend = FALSE,
  legend_position = "none",
  show_title = FALSE
)

layout_config <- new_layout_config(
  panel_border = TRUE,
  width = 6.77165,
  height = 6,
  dpi = 300,
  reverse_x = 1,
  x_limits = c(-15, 13),
  y_limits = c(-50, 50),
  # x_limits = c(-3.1, 3.1),
  # y_limits = c(-3, 4),
  plot_margin = margin(0.05, 0.05, 0.05, 0.05, "cm"),
  save_format = "pdf"
)
```


### original data
```{r}
for(ndim in sim_data$metadata$dimension) {
  # Map the original coordinates
  original_coords <- sim_data$coordinates[[which(sim_data$metadata$dimension == ndim)]]
  original_coords$name <- original_coords$unique_id
  # Assign new column names to the first ndim columns
  col_names <- paste0("V", 1:ndim)
  colnames(original_coords)[1:ndim] <- col_names

  # Add antigen/antiserum indicators based on rownames
  original_coords$antigen <- startsWith(original_coords$name, "V/")
  original_coords$antiserum <- startsWith(original_coords$name, "S/")
  # Extract year from names - assuming format like "V/strain/year" or "S/strain/year"
  original_coords$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", original_coords$name))

  original_coords$name <- sub("^S/", "", original_coords$name)
  original_coords$name <- sub("^V/", "", original_coords$name)

  # Create and save temporal plot
  temporal_plot <- plot_temporal_mapping(
    original_coords,
    ndim = ndim,
    dim_config = dim_config,
    aesthetic_config = aesthetic_config,
    layout_config = layout_config
  )

  ggsave(
    file.path(plots_dir,
             sprintf("original_temporal_map_dim%d.pdf", ndim)),
    temporal_plot,
    width = layout_config$width,
    height = layout_config$height,
    dpi = layout_config$dpi
  )
}
```

```{r}
# First modify aesthetic configs for different legend handling
aesthetic_config_with_legend <- aesthetic_config
aesthetic_config_with_legend$show_legend <- TRUE
aesthetic_config_with_legend$legend_position <- "right"

aesthetic_config_no_legend <- aesthetic_config
aesthetic_config_no_legend$show_legend <- FALSE
aesthetic_config_no_legend$legend_position <- "none"

# Create plots
plots <- list()
for (i in 1:3) {
  ndim <- sim_data$metadata$dimension[i]
  
  # Get coordinates for this dimension
  original_coords <- sim_data$coordinates[[which(sim_data$metadata$dimension == ndim)]]
  original_coords$name <- original_coords$unique_id
  
  # Assign column names
  col_names <- paste0("V", 1:ndim)
  colnames(original_coords)[1:ndim] <- col_names
  
  # Add indicators and extract year
  original_coords$antigen <- startsWith(original_coords$name, "V/")
  original_coords$antiserum <- startsWith(original_coords$name, "S/")
  original_coords$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", original_coords$name))
  original_coords$name <- sub("^[VS]/", "", original_coords$name)
  
  # Create plot with or without legend
  aesthetic_config_to_use <- if(i == 3) aesthetic_config_with_legend else aesthetic_config_no_legend
  
  plots[[i]] <- plot_temporal_mapping(
    original_coords,
    ndim = ndim,
    dim_config = dim_config,
    aesthetic_config = aesthetic_config_to_use,
    layout_config = layout_config
  ) + 
    ggtitle(sprintf("%dD", ndim))  # Add dimension as title
}

# Create combined plot
combined_plot <- plot_grid(
  plots[[1]], plots[[2]], plots[[3]],
  labels = c("A. Dim=2", "B. Dim=5", "C. Dim=10"),
  label_size = 8,
  nrow = 1,
  align = 'h',
  axis = 'tb',
  rel_widths = c(1, 1, 1.6)  # Make the last panel slightly wider to accommodate legend
)

# Save combined plot
save_plot(
  file.path(plots_dir, "combined_temporal_plots.pdf"),
  combined_plot,
  ncol = 3,
  nrow = 1,
  base_width = layout_config$width/3.2,  # or Slightly wider to accommodate legend
  base_height = layout_config$height
)
```

### Topolow vs RACMACS on 10D scenarios

Run this block after previous block.

```{r}
ndim = sim_data$metadata$dimension[3]
matrix_type = matrix_variants[9]
# Get scenario names
base_scenario <- sprintf("synthetic_dim%d_%s", ndim, matrix_type)
# Get the matrices for this dimension
dim_data <- sim_data$matrices[[which(sim_data$metadata$dimension == ndim)]][[14]]


# Topolow plot:

topolow_coords_file <- file.path(coords_dir, 
                             sprintf("coords_dim%d_%s.csv", ndim, matrix_type))

positions_df <- read.csv(topolow_coords_file)
positions_df$name <- positions_df$X
# Add antigen/antiserum indicators based on rownames
positions_df$antigen <- startsWith(positions_df$name, "V/")
positions_df$antiserum <- startsWith(positions_df$name, "S/")
# Extract year from names - assuming format like "V/strain/year" or "S/strain/year"
positions_df$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", positions_df$name))

positions_df$name <- sub("^S/", "", positions_df$name)
positions_df$name <- sub("^V/", "", positions_df$name)

# Get the optimal parameters
amc_files <- c(
  file.path("model_parameters",
            sprintf("synthetic_dim%d_%s_model_parameters.csv", 
                   ndim, matrix_type)),
  file.path("model_parameters",
            sprintf("synthetic_MC2_dim%d_%s_model_parameters.csv", 
                   ndim, matrix_type)),
  file.path("model_parameters",
            sprintf("synthetic_MC7_dim%d_%s_model_parameters.csv", 
                   ndim, matrix_type))
)

# Combine chain results
amc_results <- do.call(rbind, lapply(amc_files, read.csv))
amc_results <- amc_results %>%
  filter(is.finite(NLL) & is.finite(Holdout_MAE)) %>%
  na.omit()
amc_results <- amc_results[amc_results$log_N >= log(2),]
amc_results <- as.data.frame(lapply(amc_results, clean_data, k = 4))
amc_results <- na.omit(amc_results)

# Find best parameters (minimum NLL)
optimal_params <- amc_results[which.min(amc_results$Holdout_MAE),]
optimal_params <- list(
  N = round(exp(as.numeric(optimal_params$log_N))),
  k0 = exp(as.numeric(optimal_params$log_k0)),
  cooling_rate = exp(as.numeric(optimal_params$log_cooling_rate)),
  c_repulsion = exp(as.numeric(optimal_params$log_c_repulsion))
)
    
# Create and save temporal plot
topolow_temporal_plot <- plot_temporal_mapping(
  positions_df,
  ndim = optimal_params$N,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config_no_legend,
  layout_config = layout_config
)


# RACMACS map

# Process RACMACS results
RACMACS_coords_file <- file.path(coords_dir, 
                       sprintf("RACMACS_coords_dim%d_%s.csv", ndim, matrix_type))
positions_racmacs <- read.csv(RACMACS_coords_file)
positions_racmacs <- na.omit(positions_racmacs)

positions_racmacs <- positions_racmacs %>%
  mutate(name = case_when(
    type == "antigen" ~ paste0("V/", name),
    type == "sera" ~ paste0("S/", name),
    TRUE ~ name
  ))

positions_racmacs <- as.data.frame(positions_racmacs)
# Add antigen/antiserum indicators based on rownames
positions_racmacs$antigen <- startsWith(positions_racmacs$name, "V/")
positions_racmacs$antiserum <- startsWith(positions_racmacs$name, "S/")
# Extract year from names - assuming format like "V/strain/year" or "S/strain/year"
positions_racmacs$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", positions_racmacs$name))

positions_racmacs$name <- sub("^S/", "", positions_racmacs$name)
positions_racmacs$name <- sub("^V/", "", positions_racmacs$name)
positions_racmacs[c('V1', 'V2')] <- positions_racmacs[c('X', 'X.1')]

# Create and save temporal plot
RACMACS_temporal_plot <- plot_temporal_mapping(
  positions_racmacs,
  ndim = 2,
  dim_config = dim_config,
  aesthetic_config = aesthetic_config_no_legend,
  layout_config = layout_config
)


# Create combined plot
combined_plot <- plot_grid(
  RACMACS_temporal_plot, topolow_temporal_plot, plots[[3]],
  labels = c("A. MDS result", "B. Topolow result", "C. Original data"),
  label_size = 7,
  nrow = 1,
  align = 'h',
  axis = 'tb',
  rel_widths = c(1, 1, 1.6)  # Make the last panel slightly wider to accommodate legend
)

# Save combined plot
save_plot(
  file.path(plots_dir, "topolow_racmacs_plots_10D_L_nb.pdf"),
  combined_plot,
  ncol = 3,
  nrow = 1,
  base_width = layout_config$width/3.2,  # or Slightly wider to accommodate legend
  base_height = layout_config$height,
  dpi = layout_config$dpi
)

```

### Topolow
Creating the maps by Topolow and their 2D projections
```{r}
for(ndim in sim_data$metadata$dimension) {
  # Get the matrices for this dimension
  dim_data <- sim_data$matrices[[which(sim_data$metadata$dimension == ndim)]]
  
  for(matrix_type in matrix_variants) { # 
    # Get scenario names
    base_scenario <- sprintf("synthetic_dim%d_%s", ndim, matrix_type)
    amc_scenario <- base_scenario
    
    # Get the optimal parameters
    amc_files <- c(
      file.path("model_parameters",
                sprintf("synthetic_dim%d_%s_model_parameters.csv", 
                       ndim, matrix_type)),
      file.path("model_parameters",
                sprintf("synthetic_MC2_dim%d_%s_model_parameters.csv", 
                       ndim, matrix_type)),
      file.path("model_parameters",
                sprintf("synthetic_MC7_dim%d_%s_model_parameters.csv", 
                       ndim, matrix_type))
    )
    
    # Combine chain results
    amc_results <- do.call(rbind, lapply(amc_files, read.csv))
    amc_results <- amc_results %>%
      filter(is.finite(NLL) & is.finite(Holdout_MAE)) %>%
      na.omit()
    amc_results <- amc_results[amc_results$log_N >= log(2),]
    amc_results <- as.data.frame(lapply(amc_results, clean_data, k = 4))
    amc_results <- na.omit(amc_results)

    # Find best parameters (minimum NLL)
    optimal_params <- amc_results[which.min(amc_results$Holdout_MAE),]
    optimal_params <- list(
      N = round(exp(as.numeric(optimal_params$log_N))),
      k0 = exp(as.numeric(optimal_params$log_k0)),
      cooling_rate = exp(as.numeric(optimal_params$log_cooling_rate)),
      c_repulsion = exp(as.numeric(optimal_params$log_c_repulsion))
    )
    
    # Get corresponding distance matrix
    distance_matrix <- dim_data[[matrix_type]]
    
    message(sprintf("\nFinding coordinates for %d dimensions and matrix type: %s", 
                   ndim, matrix_type))
    
    # Run topolow with error handling
    topo_result <- tryCatch({
      create_topolow_map(
        distance_matrix = distance_matrix,
        ndim = optimal_params$N,
        mapping_max_iter = 5000,
        relative_epsilon = 1e-10,
        convergence_counter = 5,
        k0 = optimal_params$k0,
        cooling_rate = optimal_params$cooling_rate,
        c_repulsion = optimal_params$c_repulsion,
        write_positions_to_csv = FALSE
      )
    }, error = function(e) {
      warning(sprintf("Error in optimization for dim %d, type %s: %s", 
                     ndim, matrix_type, e$message))
      return(NULL)
    })
    
    if(!is.null(topo_result)) {
      # Save coordinates
      coords_file <- file.path(coords_dir, 
                             sprintf("coords_dim%d_%s.csv", ndim, matrix_type))
      write.csv(as.data.frame(topo_result$positions), 
                coords_file, row.names = TRUE)
      
      #positions_df <- as.data.frame(topo_result$positions)
      positions_df <- read.csv(coords_file)
      positions_df$name <- positions_df$X
      # Add antigen/antiserum indicators based on rownames
      positions_df$antigen <- startsWith(positions_df$name, "V/")
      positions_df$antiserum <- startsWith(positions_df$name, "S/")
      # Extract year from names - assuming format like "V/strain/year" or "S/strain/year"
      positions_df$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", positions_df$name))
      
      positions_df$name <- sub("^S/", "", positions_df$name)
      positions_df$name <- sub("^V/", "", positions_df$name)

      # Create and save temporal plot
      temporal_plot <- plot_temporal_mapping(
        positions_df,
        ndim = optimal_params$N,
        dim_config = dim_config,
        aesthetic_config = aesthetic_config,
        layout_config = layout_config
      )
      
      ggsave(
        file.path(plots_dir,
                 sprintf("Topolow_temporal_map_dim%d_%s.pdf", ndim, matrix_type)),
        temporal_plot,
        width = layout_config$width,
        height = layout_config$height,
        dpi = layout_config$dpi
      )
    }
  }
}
```

### MDS

Creating the maps by MDS and their 2D maps

```{r eval=FALSE}
# 1- Creating the maps by MDS 
for(ndim in sim_data$metadata$dimension) {
  # Get the matrices for this dimension
  dim_data <- sim_data$matrices[[which(sim_data$metadata$dimension == ndim)]]
  
  for(matrix_type in matrix_variants) { # 
    # Get scenario names
    base_scenario <- sprintf("synthetic_dim%d_%s", ndim, matrix_type)
    
    # Get corresponding distance matrix
    distance_matrix <- dim_data[[matrix_type]]
    
    message(sprintf("\nFinding coordinates for %d dimensions and matrix type: %s", 
                   ndim, matrix_type))
    
    # Convert to titer format for RACMACS
    titer_table <- dist_to_titer_table(distance_matrix, base=2, tens=10)

    # Run RACMACS optimization
    map <- create_and_optimize_RACMACS_map(
      titer_table = titer_table,
      dim = 2,
      optimization_number = opt_params$racmacs_opt_rounds,
      num_cores = opt_params$num_cores,
      scenario_name = base_scenario
    )

    # Save coordinates
    coords_file <- file.path(coords_dir, 
                           sprintf("RACMACS_coords_dim%d_%s.csv", ndim, matrix_type))
      
    save.coords(map, filename = coords_file,
               optimization_number = 1, antigens = TRUE, sera = TRUE)

  }
}
```

```{r eval=FALSE}
# 2- plotting 2D maps
for(ndim in sim_data$metadata$dimension) {
  # Get the matrices for this dimension
  dim_data <- sim_data$matrices[[which(sim_data$metadata$dimension == ndim)]]
  
  for(matrix_type in matrix_variants) {
    # Process RACMACS results
    coords_file <- file.path(coords_dir, 
                           sprintf("RACMACS_coords_dim%d_%s.csv", ndim, matrix_type))
    positions_racmacs <- read.csv(coords_file)
    positions_racmacs <- na.omit(positions_racmacs)

    positions_racmacs <- positions_racmacs %>%
      mutate(name = case_when(
        type == "antigen" ~ paste0("V/", name),
        type == "sera" ~ paste0("S/", name),
        TRUE ~ name
      ))

    positions_racmacs <- as.data.frame(positions_racmacs)
    # Add antigen/antiserum indicators based on rownames
    positions_racmacs$antigen <- startsWith(positions_racmacs$name, "V/")
    positions_racmacs$antiserum <- startsWith(positions_racmacs$name, "S/")
    # Extract year from names - assuming format like "V/strain/year" or "S/strain/year"
    positions_racmacs$year <- as.numeric(sub(".*/([0-9]+).*", "\\1", positions_racmacs$name))
    
    positions_racmacs$name <- sub("^S/", "", positions_racmacs$name)
    positions_racmacs$name <- sub("^V/", "", positions_racmacs$name)
    positions_racmacs[c('V1', 'V2')] <- positions_racmacs[c('X', 'X.1')]

    # Create and save temporal plot
    temporal_plot <- plot_temporal_mapping(
      positions_racmacs,
      ndim = 2,
      dim_config = dim_config,
      aesthetic_config = aesthetic_config,
      layout_config = layout_config
    )
    
    ggsave(
      file.path(plots_dir,
               sprintf("RACMACS_temporal_map_dim%d_%s.pdf", ndim, matrix_type)),
      temporal_plot,
      width = layout_config$width,
      height = layout_config$height,
      dpi = layout_config$dpi
    )
  }
}
```



```{r}
sessionInfo()
```
