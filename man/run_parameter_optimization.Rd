% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_sampling.R
\name{run_parameter_optimization}
\alias{run_parameter_optimization}
\title{Run Parameter Optimization Via Latin Hypercube Sampling}
\usage{
run_parameter_optimization(
  distance_matrix,
  max_iter,
  relative_epsilon,
  convergence_counter,
  scenario_name,
  N_min,
  N_max,
  k0_min,
  k0_max,
  c_repulsion_min,
  c_repulsion_max,
  cooling_rate_min,
  cooling_rate_max,
  num_samples,
  folds = 20,
  verbose = FALSE,
  write_files = TRUE,
  output_dir = NULL,
  num_cores = 1,
  time = "8:00:00",
  memory = "10G",
  use_slurm = FALSE,
  cider = FALSE
)
}
\arguments{
\item{distance_matrix}{Matrix or data frame. Input distance matrix. Must be square
and symmetric. Can contain NA values for missing measurements.}

\item{max_iter}{Integer. Maximum number of optimization iterations.}

\item{relative_epsilon}{Numeric. Convergence threshold for relative change in error.}

\item{convergence_counter}{Integer. Number of iterations below threshold before
declaring convergence.}

\item{scenario_name}{Character. Name for output files and job identification.}

\item{N_min, N_max}{Integer. Range for number of dimensions parameter.}

\item{k0_min, k0_max}{Numeric. Range for initial spring constant parameter.}

\item{c_repulsion_min, c_repulsion_max}{Numeric. Range for repulsion constant parameter.}

\item{cooling_rate_min, cooling_rate_max}{Numeric. Range for spring decay parameter.}

\item{num_samples}{Integer. Number of LHS parameter samples to evaluate.}

\item{folds}{Integer. Number of cross-validation folds. Default: 20.}

\item{verbose}{Logical. Whether to print progress messages. Default: FALSE.}

\item{write_files}{Logical. Whether to save results to CSV. Default: TRUE.}

\item{output_dir}{Character. Directory where output and temporary files will be saved. If NULL,
uses current working directory. Directory will be created if it doesn't exist.}

\item{num_cores}{Integer. Number of CPU cores to use for parallel processing.
Default: 1.}

\item{time}{Character. Walltime for SLURM jobs in HH:MM:SS format. Default: "8:00:00".}

\item{memory}{Character. Memory allocation for SLURM jobs. Default: "10G".}

\item{use_slurm}{Logical. Whether to submit jobs via SLURM. Default: FALSE.}

\item{cider}{Logical. Whether to use cider queue in SLURM. Default: FALSE.}
}
\value{
If write_files=FALSE, returns a data frame with columns:
\item{N}{Number of dimensions used}
\item{k0}{Initial spring constant}
\item{cooling_rate}{Spring decay rate}
\item{c_repulsion}{Repulsion constant}
\item{Holdout_MAE}{Mean absolute error on validation sets}
\item{NLL}{Negative log likelihood}

If write_files=TRUE, results are saved to CSV files in the format:
\{scenario_name\}_model_parameters.csv
}
\description{
Performs parameter optimization using Latin Hypercube Sampling (LHS) combined with
k-fold cross-validation. Parameters are sampled from specified ranges using maximin
LHS design to ensure good coverage of parameter space. Each parameter set is evaluated
using k-fold cross-validation to assess prediction accuracy.
}
\details{
The function performs these steps:
\enumerate{
\item Generates LHS samples in parameter space
\item Creates k-fold splits of input data
\item For each parameter set and fold:
\itemize{
\item Trains model on training set
\item Evaluates on validation set
\item Calculates MAE and negative log likelihood
}
\item Can run computation locally or distribute via SLURM
}

Parameters ranges are transformed to log scale where appropriate to handle
different scales effectively.
}
\examples{
\dontrun{
# Generate sample distance matrix
dist_mat <- matrix(runif(100), 10, 10)
dist_mat[lower.tri(dist_mat)] <- t(dist_mat)[lower.tri(dist_mat)]
diag(dist_mat) <- 0

# Run local optimization
results <- run_parameter_optimization(
  distance_matrix = dist_mat,
  max_iter = 1000,
  relative_epsilon = 1e-4,
  convergence_counter = 10,
  scenario_name = "test_opt",
  N_min = 2, N_max = 10,
  k0_min = 1, k0_max = 30,
  c_repulsion_min = 0.00001, c_repulsion_max = 0.2,
  cooling_rate_min = 0.00001, cooling_rate_max = 0.2,
  num_samples = 20,
  num_cores = 4
)

# Run with SLURM
run_parameter_optimization(
  distance_matrix = dist_mat,
  max_iter = 1000,
  scenario_name = "slurm_opt",
  N_min = 2, N_max = 10,
  num_samples = 50,
  use_slurm = TRUE
)
}

}
\seealso{
\code{\link{create_topolow_map}} for the core optimization algorithm
}
