% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data_preprocessing.R
\name{prune_sparse_matrix}
\alias{prune_sparse_matrix}
\title{Prune Sparse Dissimilarity Matrix to Well-Connected Subset}
\usage{
prune_sparse_matrix(
  dissimilarity_matrix,
  min_connections = 4,
  target_completeness = NULL,
  max_iterations = 100,
  min_points = 10,
  ensure_connected = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{dissimilarity_matrix}{Square symmetric dissimilarity matrix. Can contain
NA values and threshold indicators (< or >).}

\item{min_connections}{Integer. Minimum number of observed dissimilarities
required per point. Points with fewer connections are iteratively removed.
Default: 4. Higher values create denser but smaller subsets.}

\item{target_completeness}{Numeric. Target network completeness (0-1) to achieve.
If specified, overrides min_connections and adaptively increases the threshold
until target is reached. Default: NULL.}

\item{max_iterations}{Integer. Maximum pruning iterations to prevent infinite loops.
Default: 100.}

\item{min_points}{Integer. Minimum number of points to retain. Stops pruning if
fewer points remain. Default: 10.}

\item{ensure_connected}{Logical. If TRUE, verifies final subset is connected and
warns if not. Requires igraph package. Default: TRUE.}

\item{verbose}{Logical. Print progress messages. Default: TRUE.}
}
\value{
A list containing:
\item{pruned_matrix}{Matrix. The pruned dissimilarity matrix.}
\item{kept_indices}{Integer vector. Row/column indices of kept points.}
\item{kept_names}{Character vector. Names of kept points (if original had names).}
\item{removed_indices}{Integer vector. Indices of removed points.}
\item{stats}{List of pruning statistics:
\itemize{
\item \code{original_size}: Original matrix dimensions
\item \code{final_size}: Final matrix dimensions
\item \code{points_removed}: Number of points removed
\item \code{percent_removed}: Percentage of points removed
\item \code{original_completeness}: Original network completeness
\item \code{final_completeness}: Final network completeness
\item \code{original_measurements}: Original number of observed values
\item \code{final_measurements}: Final number of observed values
\item \code{iterations}: Number of pruning iterations
\item \code{min_connections_used}: Final min_connections threshold
\item \code{is_connected}: Whether final subset is connected (if checked)
\item \code{n_components}: Number of connected components (if checked)
}
}
}
\description{
Iteratively removes poorly connected points from a sparse dissimilarity matrix
to create a well-connected, denser subset suitable for optimization and subsampling.
This is particularly useful for very sparse datasets (>95\% missing) where random
subsampling would create disconnected graphs.
}
\details{
The function works by:
\enumerate{
\item Counting observed measurements per point (row/column)
\item Identifying points below the threshold
\item Removing those points and their measurements
\item Repeating until all remaining points meet the threshold
\item Optionally verifying connectivity
}

\strong{Choosing min_connections:}
\itemize{
\item For very sparse data, start with min_connections = 3-10
\item For target completeness, use target_completeness instead
}

\strong{Adaptive thresholding with target_completeness:}
If target_completeness is specified, the function:
\enumerate{
\item Starts with min_connections = 4
\item Prunes the matrix
\item Checks if completeness target is met
\item If not, increases min_connections by 1 and repeats
\item Stops when target is reached or min_points is hit
}
}
\examples{
# Create a sparse matrix
set.seed(123)
n <- 1000
mat <- matrix(NA, n, n)
diag(mat) <- 0
# Add only 1\% observations
n_obs <- floor(n * n * 0.01)
indices <- sample(which(upper.tri(mat)), n_obs)
mat[indices] <- runif(n_obs, 0, 10)
mat[lower.tri(mat)] <- t(mat)[lower.tri(mat)]

# Prune with minimum connections
result <- prune_sparse_matrix(mat, min_connections = 15)
print(result$stats)

# Prune to target completeness
result2 <- prune_sparse_matrix(mat, target_completeness = 0.05)
print(result2$stats)

}
\seealso{
\code{\link{check_matrix_connectivity}} for checking connectivity,
\code{\link{analyze_network_structure}} for network analysis
}
