% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/core.R
\name{incremental_embedding}
\alias{incremental_embedding}
\title{Incremental Euclidean Embedding}
\usage{
incremental_embedding(
  fixed_positions,
  new_measurements,
  object_col = "object",
  reference_col = "reference",
  value_col = "value",
  mapping_max_iter = 1000,
  k0 = 1,
  cooling_rate = 0.01,
  c_repulsion = 0.01,
  relative_epsilon = 1e-04,
  convergence_counter = 5,
  n_negative_samples = 5,
  convergence_check_freq = 10,
  verbose = FALSE
)
}
\arguments{
\item{fixed_positions}{Matrix. Coordinates of existing points that should remain
fixed during optimization. Row names must identify the points.}

\item{new_measurements}{Data frame in long format containing new measurements.
Must have columns for object identifiers, reference identifiers, and
dissimilarity values.}

\item{object_col}{Character. Name of the column containing object identifiers.
Default is "object".}

\item{reference_col}{Character. Name of the column containing reference identifiers.
Default is "reference".}

\item{value_col}{Character. Name of the column containing dissimilarity values.
Can include threshold indicators (< or >). Default is "value".}

\item{mapping_max_iter}{Integer. Maximum number of optimization iterations.
Default is 1000.}

\item{k0}{Numeric. Initial spring constant controlling spring forces. Default is 1.0.}

\item{cooling_rate}{Numeric. Rate of spring constant decay per iteration
(0 < cooling_rate < 1). Default is 0.01.}

\item{c_repulsion}{Numeric. Repulsion constant controlling repulsive forces.
Default is 0.01.}

\item{relative_epsilon}{Numeric. Convergence threshold for relative change in error.
Default is 1e-4.}

\item{convergence_counter}{Integer. Number of consecutive iterations below threshold
before declaring convergence. Default is 5.}

\item{n_negative_samples}{Integer. Number of negative samples per edge endpoint.
Default is 5.}

\item{convergence_check_freq}{Integer. How often to check for convergence.
Default is 10.}

\item{verbose}{Logical. Whether to print progress messages. Default is FALSE.}
}
\value{
A \code{list} object of class \code{topolow} containing:
\itemize{
\item \code{positions}: Matrix of all point coordinates (fixed + new points)
\item \code{est_distances}: Matrix of Euclidean distances in the final configuration
\item \code{mae}: Mean Absolute Error on edges involving new points
\item \code{iter}: Number of iterations performed
\item \code{parameters}: List of optimization parameters used
\item \code{convergence}: List with convergence status and final error
\item \code{incremental_info}: List with details about the incremental update:
\itemize{
\item \code{n_fixed_points}: Number of points kept fixed
\item \code{n_new_points}: Number of newly added points
\item \code{n_new_edges}: Number of edges processed (involving new points)
\item \code{new_point_names}: Names of the newly added points
\item \code{warnings}: Any warnings generated during processing
}
}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Adds new points to an existing Euclidean embedding while keeping the positions
of existing points fixed. This is useful for incrementally updating antigenic
maps as new measurements become available, without re-optimizing the entire map.
}
\details{
The goal of incremental embedding is to produce results equivalent to
re-optimizing the entire map from scratch, while being computationally
efficient by only optimizing new points.
\subsection{Algorithm Steps}{
\enumerate{
\item Takes fixed positions of existing points and new measurements
\item Identifies truly new points (those not in existing positions)
\item Constructs a merged dissimilarity matrix:
\itemize{
\item Fixed-to-fixed distances come from existing positions (NEVER from new_measurements)
\item New-to-fixed and new-to-new distances come from new_measurements
}
\item Reorders the matrix for optimal convergence (spectral ordering)
\item Initializes new point positions near their nearest fixed anchor
\item Optimizes only new point positions via C++ backend
\item Only processes edges involving at least one new point (efficiency)
\item Applies extra repulsion to compensate for reduced negative sampling
}
}

\subsection{Key Design Decisions}{

\strong{Decision 1: Fixed Point Mask}
Points are marked as fixed (1) or optimizable (0). Fixed points never move;
only new points are optimized based on new measurements.

\strong{Decision 2: Edge Filtering}
Only edges involving at least one new point are processed. For 1000 fixed +
10 new points, this means ~20,000 edges instead of ~500,000.

\strong{Decision 3: Force Compensation}
In standard optimization, spring forces move BOTH endpoints. When one
endpoint is fixed, only one point moves, causing ~half the distance change.
To compensate, forces are scaled by factor (1 + norm_movable/norm_fixed).
This ensures equivalent convergence behavior to full optimization.

\strong{Decision 4: Extra Repulsion Pass}
Edge filtering reduces negative sampling opportunities from fixed points.
To compensate, explicit repulsion is applied from randomly sampled fixed
points to each new point after each iteration.

\strong{Decision 5: Contradictory Data Prevention}
Fixed-fixed distances in the matrix come ONLY from existing positions.
Any fixed-fixed measurements in new_measurements are ignored to prevent
impossible geometric constraints.

\strong{Decision 6: Immediate (Gauss-Seidel) Updates}
Positions are updated immediately when visited, matching the original
topolow algorithm's behavior.

The function leverages the same C++ optimization backend as \code{\link[=euclidean_embedding]{euclidean_embedding()}}
but with modifications for fixed-point handling and force compensation.
}
}
\examples{
# Create an initial map
initial_dist <- matrix(c(0, 2, 3, 2, 0, 4, 3, 4, 0), nrow = 3)
rownames(initial_dist) <- colnames(initial_dist) <- c("A", "B", "C")

initial_map <- euclidean_embedding(
  dissimilarity_matrix = initial_dist,
  ndim = 2, mapping_max_iter = 100,
  k0 = 1.0, cooling_rate = 0.01, c_repulsion = 0.01
)

# Add new points with new measurements
new_data <- data.frame(
  object = c("D", "D", "E"),
  reference = c("A", "B", "C"),
  value = c(2.5, 3.0, 1.5)
)

updated_map <- incremental_embedding(
  fixed_positions = initial_map$positions,
  new_measurements = new_data,
  mapping_max_iter = 100,
  k0 = 1.0, cooling_rate = 0.01, c_repulsion = 0.01
)

}
\seealso{
\code{\link[=euclidean_embedding]{euclidean_embedding()}} for creating initial embeddings,
\code{\link[=list_to_matrix]{list_to_matrix()}} for converting list data to matrix format.
}
