% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/diagnostics.R
\name{plot_performance_trace}
\alias{plot_performance_trace}
\title{Plot Running Minimum Error to Show Sampling Convergence}
\usage{
plot_performance_trace(
  chain_files,
  metric = "both",
  combine_chains = TRUE,
  sort_combined = TRUE,
  show_raw = TRUE,
  window_size = NULL,
  output_file = NULL,
  width = 10,
  height = 6,
  dpi = 300
)
}
\arguments{
\item{chain_files}{Character vector. Paths to CSV files containing sampling chains.}

\item{metric}{Character. Which metric to plot: "NLL", "MAE", or "both". Default: "both"}

\item{combine_chains}{Logical. If TRUE, combines all chains into one sequence.
If FALSE, plots each chain separately. Default: TRUE}

\item{sort_combined}{Logical. If TRUE and \code{combine_chains} is TRUE, sorts combined
samples from worst to best for each metric independently before computing the
running minimum. This produces a smooth monotonic improvement curve that is not
biased by chain ordering. If FALSE, chains are concatenated sequentially (original
behavior). Default: TRUE}

\item{show_raw}{Logical. If TRUE, shows raw values as points behind the running minimum.
Default: TRUE}

\item{window_size}{Integer. Window size for computing rolling mean (optional smoothing).
Set to NULL for no smoothing. Default: NULL}

\item{output_file}{Character. Optional path to save the plot. Default: NULL}

\item{width, height}{Numeric. Dimensions for saved plot. Default: 10, 6}

\item{dpi}{Numeric. Resolution for saved plot. Default: 300}
}
\value{
A ggplot object showing the error plateau diagnostic.
}
\description{
Creates a diagnostic plot showing how the best (minimum) NLL or MAE found improves
over iterations and eventually plateaus. This is a standard way to demonstrate that
sampling/optimization has converged in terms of the objective function.
}
\details{
The "running minimum" (or cumulative minimum) shows the best value found so far
at each iteration. When this line flattens out (plateaus), it indicates that
the sampling has found the optimal region and additional samples are not
improving the objective.

When \code{combine_chains = TRUE} and \code{sort_combined = TRUE}, samples from all chains
are sorted from worst (highest) to best (lowest) independently for each metric
before computing the running minimum. This avoids the problem where the first
chain in the list dominates the visual, and produces a smooth improvement curve
showing how quality improves across the full pool of samples. Each metric facet
has its own sort order, so the NLL panel sorts by NLL and the MAE panel sorts
by MAE.

This is distinct from:
\itemize{
\item Trace plots (which show parameter values, not objective function)
\item R-hat (which measures between-chain variance)
\item ESS (which measures autocorrelation)
}
}
\examples{
\dontrun{
# Basic usage (sorted by default)
chain_files <- c("chain1.csv", "chain2.csv", "chain3.csv")
plot_performance_trace(chain_files)

# Original sequential concatenation behavior
plot_performance_trace(chain_files, sort_combined = FALSE)

# Plot only NLL with separate chains
plot_performance_trace(chain_files, metric = "NLL", combine_chains = FALSE)

# Save the plot
plot_performance_trace(chain_files, output_file = "fig/convergence_plateau.png")
}

}
